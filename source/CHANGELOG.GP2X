2008-05-06:
 - Fixed a centered text bug (only present in the menus).
 - Fixed the blit rubbish which resulted from the drag-crash bugfix?
 - Fixed timers in paused (only affects mines at this point anyway)
 - Rejigged the menu positions a bit to get enough space for some more key-instructions

2008-05-03:
 - Implemented game saving with ten slots per game.
	At the moment, it saves to a file with the name <gamename>N.sav where gamename is map,
	bridges, rectangles, etc. and N is the save slot (0-9).
	Press L or R in the menu to select the savegame slot (don't press them both at once!)
	Press Select in the menu to save the game
	Press Vol+/Vol- in the menu (at the same time) to load a game
        You can load any games that you might have saved from PC versions if you put them
	in the right place and give them the right names (e.g. you can open the example games 
	that are used to generate the game icons etc.)
 - Fixed long-standing drag-crash bug (why did nobody tell me that this was so easy to trigger?)
	Dragging a circle off the top or left edge would crash the game.
        Now, it just makes it look a little ugly.  I will fix this but it's a little more 
	complex than it at first looks.  Basically the blitter is being fed rubbish when the 
	game draws the drag-cursors near the top-left edge of the screen and it's hard to tell
	what should be done in that case (the developer documentation gives a suggestion that
	is hard to implement and a little uncertain to work).
 - Changed all drawing code to check more if it's being asked to draw the impossible.
	Will slow some things down but will stop silly crashes like the above in the future.
 - Implemented mouse acceleration by rewriting pretty much the entire mouse code.
	If people whinge, I can make this configurable for speed.
        Sometimes it "sticks" but that's an easy fix (hopefully).
 - Removed a few more useless bits of code, variables etc.
	Might save a few bytes of two here and there.
 - Added instructions for new buttons and their uses to the configuration page.
 - A few fixes to the way things print/update the screen for the new cases (save, load etc.)

2008-04-28:
 - Stopped "solve" from printing over the menu.
 - Implemented basic configuration saving to plaintext INI files.
	I used the MIT-licensed INIParser library.  Unfortunately, it had one function
	misnamed in the source, and I had to insert a few #ifdef's around some error
        messages so that they didn't clobber normal game messages, but it works fine.

        Press X in the Pause menu to save the current config as the default (if it is
        valid, of course, or you'll just get the normal messages for invalid configs).

        If the INI file is invalid/corrupt/missing/unreadable, it will just use the 
	game's default settings.  If you want to "reset" the defaults, delete
	the relevant INI file (e.g. net.ini, bridges.ini etc.)
 - Seperated out debug functions so that you can debug parts of the program without 
   getting log-floods from everything.
	You can now select DEBUG_FILE_ACCESS, DEBUG_DRAWING, DEBUG_MOUSE etc.
 - Closed a couple of improperly-freed variables
	Wouldn't matter much unless you were running the GP2X for days on end, when it
	might run out of RAM.
 - Modified the Makefile so that it can UPX the ARM executables directly.

2008-04-21:
 - Centered all puzzles on the screen.
 - Remove an unused variable (leftover GTK cruft from the conversion)
	Should save about a meg or so of RAM.
 - After a semi-succesful trial, have decided against hardware "acceleration" entirely.
	I managed to get hardware surface, double-buffering and even triple-buffering
	working properly with no display artifacts.  BUT...
	For the purposes of these games, there is absolutely zero advantage, even with
	double-buffering etc.  You don't get much acceleration at all, you don't get
	smoother drawing.  Triple-buffering doesn't do anything noticeable.  You don't
	"speed" anything up because the games decide when to update themselves etc. and
	sometimes only do partial updates.  Even if they do it to an offscreen surface
	that you then use to do triple-buffering from, you get next to zero visible
	difference.  You don't save any CPU, but just use up more RAM.

2008-04-18 - BETA 3:
 - Fixed two problems with clipping because of the new pause menu.
 - Increased font size in pause menu and made it "clip" so that it doesn't overlap other text.
 - Prettied-up the pause menu a bit by rearranging and drawing a line.
 - Small fix to net to remove a tiny bit of unused library code.
 - Included tons of debugging info for developers (enabled by config option).

2008-04-17:
 - Anti-aliased all primitives that allow it and which can safely overwrite each other.
 - Improved quality of text by using anti-aliased, alpha-blended rendered text.
 - Improved game configuration to remove problems associated with options not fitting and
   options requiring decimal numbers (fudged for net and netslide probabilities too).
 - Added help text loading for all games.
 - Background colours tweaked slightly.
 - Compressed all executables with UPX, reducing their size by 50%.

2008-04-13:
 - Implemented pause on the Start button.
 - Implemented game-independent colour routines to define black and white for text no matter 
   what the game uses, so that the status bar always shows up.
 - Added game configurability for all games under the Pause menu.
	This greatly increases the potential of the puzzle colleciton and lets you configure
	the types of puzzles in all manner of ways.  So you can play bridges on a giant board,
	cube with an octagon, dominosa with more dominoes, solo in a number of different ways,
	net so that the board "wraps" and a million others.
	The Pause menu hides all the configuration, and you have to start a new game from there
	for the options to take effect.  The games will tell you if you have set options
	incorrectly, e.g. tried to play on a -1 x -1 board etc.
	Still flaky for some games because:
		- It really needs scrolling for the games with more options (e.g. bridges).
		- Some games want you to be able to enter non-integer numbers (e.g. 0.1) but 
		  it's almost impossible to distinguish which games need this programmatically.
 - Revamped the use of colours a bit, no more colour conversions on every primitive draw.
 - Added loading of game instructions from text files.

2008-04-09 - BETA 2:
 - Slightly improved status-bar drawing to stop stray pixels when a "descender" character
   is printed.
 - Abstracted font filename constants so they can be changed easily
 - Coloured the whole background on startup instead of just the puzzle background.
	I may revert this, I'm not sure yet.
 - Removed a few more unused variables.
 - Improved locking a bit more and re-tried hardware surfaces.
	Still not worth the effort as the midend doesn't really "know" about double-buffering
	and to teach it removes almost all of the benefits.  And with plain HW surfaces, you
	get tearing.
 - Narrowed down mines behaviour to ARM peculiarities.
	ARM's signedness and endianness are different and this causes problems with the only
	game to use signed/unsigned char's (specifically comparison to negative integers) and 
	bit-shifting.  So it looks like this is outside the scope of this port until the 
	upstream files are fixed.  I've sent an email to the author for help with this problem.

2008-04-08:
 - Abstracted some constants (screen height, width, colour depth, statusbar font size etc.) so 
   that they can be changed easily without having to hunt through code.
 - Added code and a new font to support monospaced fonts.
	Nothing uses it yet but this is for completeness in case anyone adds new games to the
	puzzle collection that requires monospaced fonts.
 - Fixed a slight bug which could see information from a free()'d surface used.
	Although a "victimless" bug so far, it was possible that a temporary surface for text 
	would be free()'d and then the size of that surface used to calculate how much screen
	to "blank" next time (often ending up by blanking nothing at all).  Re-ordered the code 
	to stop it doing that (strange that nothing complained, though).
 - Re-jigged mouse cursors again
	Hopefully put a stop to the F-200 touchscreen / USB mouse weirdness.  Also, I changed 
	some timings back now that I've stopped timing-related mouse problems.  Smoother
	animation may or may not result. :-)
 - Moved the initial mouse cursor to the centre of the puzzle instead of the top-left corner.
 - Documented some more code and the Makefile a little.
 - Added font alignment.
	Only seems to be used for tents and only produces a slight shift to the bottom row
	of text.  But, again, for the sake of completeness, it's done.

2008-04-07:
 - Fixed map's and inertia's drag-drop display problem.
	I'm a pillock.  Having your source and destination the wrong way round means
	that any amount of checking of your parameter values is useless if you don't 
	check the ORDER of arguments as well.  I still say that the functions use
	a "backwards" nomenclature for "blitter save/load" but once I switched them
	around, it all started working properly without any other hassles.
 - Fixed pegs and sped up all games by putting screen updates in the right places.
	I'm still a pillock.  Although it still draws lots of primitives, we *now* don't 
	update on every one of them, just the final "drawing".  So instead of many 
	intra-frame updates, we get one end-of-frame update.  The documentation wasn't 
	at all clear on this but I should have debugged it properly earlier.
        Also, implemented proper "partial updates" instead of full updates all the time.
 - Implemented re-use of loaded fonts.
	Increases speed of text games at a cost of memory.  I didn't do this before for
	debugging reasons and because it worked without it but for the sake of completeness
	it now keeps copies of fonts in multiple sizes in RAM in case it re-uses them rather
	than constantly load/destroy/load/destroy fonts as the sizes in use changes.
	It still doesn't distinguish "types" of fonts (monospaced etc.) but that's only a 
	minor addition.
 - Better descriptive text for errors/startup.
	You won't see them unless you are using Sterm / Telnet to run the games but when
	something goes wrong, you're more likely to get a useful error message.
 - Removed a few bits of unused / unnecessary SDL code.
	e.g. initialising audio, overzealous locking, freeing of surfaces that get freed
	anyway,...
 - Tested code with proper hardware accelerated surfaces.
	Little to no performance difference but strange problems related to dragging in
        untangle, for example, which gives "jittery" cursors when using page-flipping.  
	Reverted until cause can be found (not a high priority given the small advantage).
 - More error checking and bailing out with a nicer error on certain failures.
	e.g. fonts not being present, blits failing, etc.
 - Looking again at mines quickly but it's still weird.  
 - Made sure that the cursor doesn't linger after the game has quit.
 - Updated to SVN 7977.
	Nothing new, except for some hidden new style of solo that you can't play yet.
	Just for the sake of making sure that upstream changes don't break anything from a
	development point of view.

2008-04-01 - BETA 1:

 - added routine to solve puzzles with Vol+ & Vol-
 - added display of currently selected digit in status bar and the statusbar itself
 - modified and improved font use, re-use and sizing of blit areas
 - improved definiton of mouse and blitting clipping areas
 - updated to latest SVN version (only a gameplay change to "filling" to allow dragging multiple tiles)
 - re-worked all the mouse code so now it works much more smoothly
 - improved most used path of event loop and changed timer settings - less CPU, same display
 - documented almost all the SDL code necessary
 - added some text to update the user on the programs progress (loading etc.)
 - fixed a memory-not-initialised problem causing stray, random key-presses.
 - found the speed problem in pegs:
        Inside game code itself.  
        MASSIVE primitives redrawing while moves take place.
	Commenting out just the blits for cursor makes no difference
	Would have to tear apart the game-drawing code to make it playable
	I say the fault lies with the individual game code itself and needs patching upstream
