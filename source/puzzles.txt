                 Simon Tatham's Portable Puzzle Collection
                 =========================================

This is a collection of small one-player puzzle games.

This manual is copyright 2004-2007 Simon Tatham. All rights reserved. You
may distribute this documentation under the MIT licence. See appendix A for
the licence text in full.

Chapter 1: Introduction
-----------------------

       I wrote this collection because I thought there should be more small
       desktop toys available: little games you can pop up in a window and
       play for two or three minutes while you take a break from whatever
       else you were doing. And I was also annoyed that every time I found
       a good game on (say) Unix, it wasn't available the next time I was
       sitting at a Windows machine, or vice versa; so I arranged that
       everything in my personal puzzle collection will happily run on
       both, and have more recently done a port to Mac OS X as well. When I
       find (or perhaps invent) further puzzle games that I like, they'll
       be added to this collection and will immediately be available on
       both platforms. And if anyone feels like writing any other front
       ends - PocketPC, Mac OS pre-10, or whatever it might be - then all
       the games in this framework will immediately become available on
       another platform as well.

       The actual games in this collection were mostly not my invention;
       they are re-implementations of existing game concepts within my
       portable puzzle framework. I do not claim credit, in general, for
       inventing the rules of any of these puzzles. (I don't even claim
       authorship of all the code; some of the puzzles have been submitted
       by other authors.)

       This collection is distributed under the MIT licence (see appendix
       A). This means that you can do pretty much anything you like with
       the game binaries or the code, except pretending you wrote them
       yourself, or suing me if anything goes wrong.

       The most recent versions, and source code, can be found at
       http://www.chiark.greenend.org.uk/~sgtatham/puzzles/.

       Please report bugs to anakin@pobox.com. You might find it helpful to
       read this article before reporting a bug:

       http://www.chiark.greenend.org.uk/~sgtatham/bugs.html

       Patches are welcome. Especially if they provide a new front end (to
       make all these games run on another platform), or a new game.

Chapter 2: Common features
--------------------------

       This chapter describes features that are common to all the games.

   2.1 Common actions

       These actions are all available from the `Game' menu and via
       keyboard shortcuts, in addition to any game-specific actions.

       (On Mac OS X, to conform with local user interface standards, these
       actions are situated on the `File' and `Edit' menus instead.)

       _New game_ (`N', Ctrl+`N')

           Starts a new game, with a random initial state.

       _Restart game_

           Resets the current game to its initial state. (This can be
           undone.)

       _Load_

           Loads a saved game from a file on disk.

       _Save_

           Saves the current state of your game to a file on disk.

           The Load and Save operations preserve your entire game history
           (so you can save, reload, and still Undo and Redo things you had
           done before saving).

       _Print_

           Where supported (currently only on Windows), brings up a dialog
           allowing you to print an arbitrary number of puzzles randomly
           generated from the current parameters, optionally including
           the current puzzle. (Only for puzzles which make sense to
           print, of course - it's hard to think of a sensible printable
           representation of Fifteen!)

       _Undo_ (`U', Ctrl+`Z', Ctrl+`_')

           Undoes a single move. (You can undo moves back to the start of
           the session.)

       _Redo_ (`R', Ctrl+`R')

           Redoes a previously undone move.

       _Copy_

           Copies the current state of your game to the clipboard in text
           format, so that you can paste it into (say) an e-mail client or
           a web message board if you're discussing the game with someone
           else. (Not all games support this feature.)

       _Solve_

           Transforms the puzzle instantly into its solved state. For some
           games (Cube) this feature is not supported at all because it is
           of no particular use. For other games (such as Pattern), the
           solved state can be used to give you information, if you can't
           see how a solution can exist at all or you want to know where
           you made a mistake. For still other games (such as Sixteen),
           automatic solution tells you nothing about how to _get_ to
           the solution, but it does provide a useful way to get there
           quickly so that you can experiment with set-piece moves and
           transformations.

           Some games (such as Solo) are capable of solving a game ID you
           have typed in from elsewhere. Other games (such as Rectangles)
           cannot solve a game ID they didn't invent themself, but when
           they did invent the game ID they know what the solution is
           already. Still other games (Pattern) can solve _some_ external
           game IDs, but only if they aren't too difficult.

           The `Solve' command adds the solved state to the end of the undo
           chain for the puzzle. In other words, if you want to go back to
           solving it yourself after seeing the answer, you can just press
           Undo.

       _Quit_ (`Q', Ctrl+`Q')

           Closes the application entirely.

   2.2 Specifying games with the game ID

       There are two ways to save a game specification out of a puzzle and
       recreate it later, or recreate it in somebody else's copy of the
       same puzzle.

       The `Specific' and `Random Seed' options from the `Game' menu (or
       the `File' menu, on Mac OS X) each show a piece of text (a `game
       ID') which is sufficient to reconstruct precisely the same game at a
       later date.

       You can enter either of these pieces of text back into the program
       (via the same `Specific' or `Random Seed' menu options) at a later
       point, and it will recreate the same game. You can also use either
       one as a command line argument (on Windows or Unix); see section 2.4
       for more detail.

       The difference between the two forms is that a descriptive game ID
       is a literal _description_ of the initial state of the game, whereas
       a random seed is just a piece of arbitrary text which was provided
       as input to the random number generator used to create the puzzle.
       This means that:

        -  Descriptive game IDs tend to be longer in many puzzles
           (although some, such as Cube (chapter 4), only need very short
           descriptions). So a random seed is often a _quicker_ way to
           note down the puzzle you're currently playing, or to tell it to
           somebody else so they can play the same one as you.

        -  Any text at all is a valid random seed. The automatically
           generated ones are fifteen-digit numbers, but anything will do;
           you can type in your full name, or a word you just made up, and
           a valid puzzle will be generated from it. This provides a way
           for two or more people to race to complete the same puzzle:
           you think of a random seed, then everybody types it in at the
           same time, and nobody has an advantage due to having seen the
           generated puzzle before anybody else.

        -  It is often possible to convert puzzles from other sources (such
           as `nonograms' or `sudoku' from newspapers) into descriptive
           game IDs suitable for use with these programs.

        -  Random seeds are not guaranteed to produce the same result
           if you use them with a different _version_ of the puzzle
           program. This is because the generation algorithm might have
           been improved or modified in later versions of the code, and
           will therefore produce a different result when given the same
           sequence of random numbers. Use a descriptive game ID if you
           aren't sure that it will be used on the same version of the
           program as yours.

           (Use the `About' menu option to find out the version number of
           the program. Programs with the same version number running on
           different platforms should still be random-seed compatible.)

       A descriptive game ID starts with a piece of text which encodes the
       _parameters_ of the current game (such as grid size). Then there is
       a colon, and after that is the description of the game's initial
       state. A random seed starts with a similar string of parameters, but
       then it contains a hash sign followed by arbitrary data.

       If you enter a descriptive game ID, the program will not be able
       to show you the random seed which generated it, since it wasn't
       generated _from_ a random seed. If you _enter_ a random seed,
       however, the program will be able to show you the descriptive game
       ID derived from that random seed.

       Note that the game parameter strings are not always identical
       between the two forms. For some games, there will be parameter
       data provided with the random seed which is not included in the
       descriptive game ID. This is because that parameter information is
       only relevant when _generating_ puzzle grids, and is not important
       when playing them. Thus, for example, the difficulty level in Solo
       (chapter 11) is not mentioned in the descriptive game ID.

       These additional parameters are also not set permanently if you type
       in a game ID. For example, suppose you have Solo set to `Advanced'
       difficulty level, and then a friend wants your help with a `Trivial'
       puzzle; so the friend reads out a random seed specifying `Trivial'
       difficulty, and you type it in. The program will generate you the
       same `Trivial' grid which your friend was having trouble with, but
       once you have finished playing it, when you ask for a new game it
       will automatically go back to the `Advanced' difficulty which it was
       previously set on.

   2.3 The `Type' menu

       The `Type' menu, if present, may contain a list of preset game
       settings. Selecting one of these will start a new random game with
       the parameters specified.

       The `Type' menu may also contain a `Custom' option which allows you
       to fine-tune game parameters. The parameters available are specific
       to each game and are described in the following sections.

   2.4 Specifying game parameters on the command line

       (This section does not apply to the Mac OS X version.)

       The games in this collection deliberately do not ever save
       information on to the computer they run on: they have no high score
       tables and no saved preferences. (This is because I expect at least
       some people to play them at work, and those people will probably
       appreciate leaving as little evidence as possible!)

       However, if you do want to arrange for one of these games to default
       to a particular set of parameters, you can specify them on the
       command line.

       The easiest way to do this is to set up the parameters you want
       using the `Type' menu (see section 2.3), and then to select `Random
       Seed' from the `Game' or `File' menu (see section 2.2). The text
       in the `Game ID' box will be composed of two parts, separated by a
       hash. The first of these parts represents the game parameters (the
       size of the playing area, for example, and anything else you set
       using the `Type' menu).

       If you run the game with just that parameter text on the command
       line, it will start up with the settings you specified.

       For example: if you run Cube (see chapter 4), select `Octahedron'
       from the `Type' menu, and then go to the game ID selection, you
       will see a string of the form `o2x2#338686542711620'. Take only the
       part before the hash (`o2x2'), and start Cube with that text on the
       command line: `cube o2x2'.

       If you copy the _entire_ game ID on to the command line, the game
       will start up in the specific game that was described. This is
       occasionally a more convenient way to start a particular game ID
       than by pasting it into the game ID selection box.

       (You could also retrieve the encoded game parameters using the
       `Specific' menu option instead of `Random Seed', but if you do then
       some options, such as the difficulty level in Solo, will be missing.
       See section 2.2 for more details on this.)

   2.5 Unix command-line options

       (This section only applies to the Unix port.)

       In addition to being able to specify game parameters on the command
       line (see section 2.4), there are various other options:

       --game

       --load

           These options respectively determine whether the command-line
           argument is treated as specifying game parameters or a save
           file to load. Only one should be specified. If neither of these
           options is specified, a guess is made based on the format of the
           argument.

       --generate _n_

           If this option is specified, instead of a puzzle being
           displayed, a number of descriptive game IDs will be invented and
           printed on standard output. This is useful for gaining access
           to the game generation algorithms without necessarily using the
           frontend.

           If game parameters are specified on the command-line, they will
           be used to generate the game IDs; otherwise a default set of
           parameters will be used.

           The most common use of this option is in conjunction with `--
           print', in which case its behaviour is slightly different; see
           below.

       --print _w_x_h_

           If this option is specified, instead of a puzzle being
           displayed, a printed representation of one or more unsolved
           puzzles is sent to standard output, in PostScript format.

           On each page of puzzles, there will be _w_ across and _h_ down.
           If there are more puzzles than _w_x_h_, more than one page will
           be printed.

           If `--generate' has also been specified, the invented game
           IDs will be used to generate the printed output. Otherwise,
           a list of game IDs is expected on standard input (which can
           be descriptive or random seeds; see section 2.2), in the same
           format produced by `--generate'.

           For example:

             net --generate 12 --print 2x3 7x7w | lpr

           will generate two pages of printed Net puzzles (each of which
           will have a 7x7 wrapping grid), and pipe the output to the `lpr'
           command, which on many systems will send them to an actual
           printer.

           There are various other options which affect printing; see
           below.

       --version

           Prints version information about the game, and then quits.

       The following options are only meaningful if `--print' is also
       specified:

       --with-solutions

           The set of pages filled with unsolved puzzles will be followed
           by the solutions to those puzzles.

       --scale _n_

           Adjusts how big each puzzle is when printed. Larger numbers make
           puzzles bigger; the default is 1.0.

       --colour

           Puzzles will be printed in colour, rather than in black and
           white (if supported by the puzzle).

Chapter 3: Net
--------------

       (_Note:_ the Windows version of this game is called NETGAME.EXE to
       avoid clashing with Windows's own NET.EXE.)

       I originally saw this in the form of a Flash game called FreeNet [1]
       , written by Pavils Jurjans; there are several other implementations
       under the name NetWalk. The computer prepares a network by
       connecting up the centres of squares in a grid, and then shuffles
       the network by rotating every tile randomly. Your job is to rotate
       it all back into place. The successful solution will be an entirely
       connected network, with no closed loops. As a visual aid, all tiles
       which are connected to the one in the middle are highlighted.

       [1] http://www.jurjans.lv/stuff/net/FreeNet.htm

   3.1 Net controls

       This game can be played with either the keyboard or the mouse. The
       controls are:

       _Select tile_: mouse pointer, arrow keys

       _Rotate tile anticlockwise_: left mouse button, `A' key

       _Rotate tile clockwise_: right mouse button, `D' key

       _Rotate tile by 180 degrees_: `F' key

       _Lock (or unlock) tile_: middle mouse button, shift-click, `S' key

           You can lock a tile once you're sure of its orientation. You
           can also unlock it again, but while it's locked you can't
           accidentally turn it.

       The following controls are not necessary to complete the game, but
       may be useful:

       _Shift grid_: Shift + arrow keys

           On grids that wrap, you can move the origin of the grid, so
           that tiles that were on opposite sides of the grid can be seen
           together.

       _Move centre_: Ctrl + arrow keys

           You can change which tile is used as the source of highlighting.
           (It doesn't ultimately matter which tile this is, as every tile
           will be connected to every other tile in a correct solution,
           but it may be helpful in the intermediate stages of solving the
           puzzle.)

       _Jumble tiles_: `J' key

           This key turns all tiles that are not locked to random
           orientations.

       (All the actions described in section 2.1 are also available.)

   3.2 Net parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in tiles.

       _Walls wrap around_

           If checked, flow can pass from the left edge to the right edge,
           and from top to bottom, and vice versa.

       _Barrier probability_

           A number between 0.0 and 1.0 controlling whether an immovable
           barrier is placed between two tiles to prevent flow between
           them (a higher number gives more barriers). Since barriers
           are immovable, they act as constraints on the solution (i.e.,
           hints).

           The grid generation in Net has been carefully arranged so that
           the barriers are independent of the rest of the grid. This
           means that if you note down the random seed used to generate
           the current puzzle (see section 2.2), change the _Barrier
           probability_ parameter, and then re-enter the same random seed,
           you should see exactly the same starting grid, with the only
           change being the number of barriers. So if you're stuck on a
           particular grid and need a hint, you could start up another
           instance of Net, set up the same parameters but a higher barrier
           probability, and enter the game seed from the original Net
           window.

       _Ensure unique solution_

           Normally, Net will make sure that the puzzles it presents have
           only one solution. Puzzles with ambiguous sections can be more
           difficult and more subtle, so if you like you can turn off this
           feature and risk having ambiguous puzzles. (Also, finding _all_
           the possible solutions can be an additional challenge for an
           advanced player.)

Chapter 4: Cube
---------------

       This is another one I originally saw as a web game. This one was a
       Java game [2], by Paul Scott. You have a grid of 16 squares, six of
       which are blue; on one square rests a cube. Your move is to use the
       arrow keys to roll the cube through 90 degrees so that it moves to
       an adjacent square. If you roll the cube on to a blue square, the
       blue square is picked up on one face of the cube; if you roll a blue
       face of the cube on to a non-blue square, the blueness is put down
       again. (In general, whenever you roll the cube, the two faces that
       come into contact swap colours.) Your job is to get all six blue
       squares on to the six faces of the cube at the same time. Count your
       moves and try to do it in as few as possible.

       Unlike the original Java game, my version has an additional feature:
       once you've mastered the game with a cube rolling on a square grid,
       you can change to a triangular grid and roll any of a tetrahedron,
       an octahedron or an icosahedron.

       [2] http://www3.sympatico.ca/paulscott/cube/cube.htm

   4.1 Cube controls

       This game can be played with either the keyboard or the mouse.

       Left-clicking anywhere on the window will move the cube (or other
       solid) towards the mouse pointer.

       The arrow keys can also used to roll the cube on its square grid in
       the four cardinal directions. On the triangular grids, the mapping
       of arrow keys to directions is more approximate. Vertical movement
       is disallowed where it doesn't make sense. The four keys surrounding
       the arrow keys on the numeric keypad (`7', `9', `1', `3') can be
       used for diagonal movement.

       (All the actions described in section 2.1 are also available.)

   4.2 Cube parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Type of solid_

           Selects the solid to roll (and hence the shape of the grid):
           tetrahedron, cube, octahedron, or icosahedron.

       _Width / top_, _Height / bottom_

           On a square grid, horizontal and vertical dimensions. On a
           triangular grid, the number of triangles on the top and bottom
           rows respectively.

Chapter 5: Fifteen
------------------

       The old ones are the best: this is the good old `15-puzzle' with
       sliding tiles. You have a 4x4 square grid; 15 squares contain
       numbered tiles, and the sixteenth is empty. Your move is to choose a
       tile next to the empty space, and slide it into the space. The aim
       is to end up with the tiles in numerical order, with the space in
       the bottom right (so that the top row reads 1,2,3,4 and the bottom
       row reads 13,14,15,_space_).

   5.1 Fifteen controls

       This game can be controlled with the mouse or the keyboard.

       A left-click with the mouse in the row or column containing the
       empty space will move as many tiles as necessary to move the space
       to the mouse pointer.

       The arrow keys will move a tile adjacent to the space in the
       direction indicated (moving the space in the _opposite_ direction).

       (All the actions described in section 2.1 are also available.)

   5.2 Fifteen parameters

       The only options available from the `Custom...' option on the `Type'
       menu are _Width_ and _Height_, which are self-explanatory. (Once
       you've changed these, it's not a `15-puzzle' any more, of course!)

Chapter 6: Sixteen
------------------

       Another sliding tile puzzle, visually similar to Fifteen (see
       chapter 5) but with a different type of move. This time, there is no
       hole: all 16 squares on the grid contain numbered squares. Your move
       is to shift an entire row left or right, or shift an entire column
       up or down; every time you do that, the tile you shift off the grid
       re-appears at the other end of the same row, in the space you just
       vacated. To win, arrange the tiles into numerical order (1,2,3,4 on
       the top row, 13,14,15,16 on the bottom). When you've done that, try
       playing on different sizes of grid.

       I _might_ have invented this game myself, though only by accident
       if so (and I'm sure other people have independently invented it). I
       thought I was imitating a screensaver I'd seen, but I have a feeling
       that the screensaver might actually have been a Fifteen-type puzzle
       rather than this slightly different kind. So this might be the one
       thing in my puzzle collection which represents creativity on my part
       rather than just engineering.

   6.1 Sixteen controls

       This game is played with the mouse. Left-clicking on an arrow will
       move the appropriate row or column in the direction indicated.
       Right-clicking will move it in the opposite direction.

       (All the actions described in section 2.1 are also available.)

   6.2 Sixteen parameters

       The parameters available from the `Custom...' option on the `Type'
       menu are:

        -  _Width_ and _Height_, which are self-explanatory.

        -  You can ask for a limited shuffling operation to be performed on
           the grid. By default, Sixteen will shuffle the grid in such a
           way that any arrangement is about as probable as any other. You
           can override this by requesting a precise number of shuffling
           moves to be performed. Typically your aim is then to determine
           the precise set of shuffling moves and invert them exactly,
           so that you answer (say) a four-move shuffle with a four-move
           solution. Note that the more moves you ask for, the more likely
           it is that solutions shorter than the target length will turn
           out to be possible.

Chapter 7: Twiddle
------------------

       Twiddle is a tile-rearrangement puzzle, visually similar to Sixteen
       (see chapter 6): you are given a grid of square tiles, each
       containing a number, and your aim is to arrange the numbers into
       ascending order.

       In basic Twiddle, your move is to rotate a square group of four
       tiles about their common centre. (Orientation is not significant
       in the basic puzzle, although you can select it.) On more advanced
       settings, you can rotate a larger square group of tiles.

       I first saw this type of puzzle in the GameCube game `Metroid
       Prime 2'. In the Main Gyro Chamber in that game, there is a puzzle
       you solve to unlock a door, which is a special case of Twiddle. I
       developed this game as a generalisation of that puzzle.

   7.1 Twiddle controls

       To play Twiddle, click the mouse in the centre of the square group
       you wish to rotate. In the basic mode, you rotate a 2x2 square,
       which means you have to click at a corner point where four tiles
       meet.

       In more advanced modes you might be rotating 3x3 or even more at a
       time; if the size of the square is odd then you simply click in the
       centre tile of the square you want to rotate.

       Clicking with the left mouse button rotates the group anticlockwise.
       Clicking with the right button rotates it clockwise.

       (All the actions described in section 2.1 are also available.)

   7.2 Twiddle parameters

       Twiddle provides several configuration options via the `Custom'
       option on the `Type' menu:

        -  You can configure the width and height of the puzzle grid.

        -  You can configure the size of square block that rotates at a
           time.

        -  You can ask for every square in the grid to be distinguishable
           (the default), or you can ask for a simplified puzzle in which
           there are groups of identical numbers. In the simplified puzzle
           your aim is just to arrange all the 1s into the first row, all
           the 2s into the second row, and so on.

        -  You can configure whether the orientation of tiles matters. If
           you ask for an orientable puzzle, each tile will have a triangle
           drawn in it. All the triangles must be pointing upwards to
           complete the puzzle.

        -  You can ask for a limited shuffling operation to be performed
           on the grid. By default, Twiddle will shuffle the grid so much
           that any arrangement is about as probable as any other. You can
           override this by requesting a precise number of shuffling moves
           to be performed. Typically your aim is then to determine the
           precise set of shuffling moves and invert them exactly, so that
           you answer (say) a four-move shuffle with a four-move solution.
           Note that the more moves you ask for, the more likely it is that
           solutions shorter than the target length will turn out to be
           possible.

Chapter 8: Rectangles
---------------------

       You have a grid of squares, with numbers written in some (but
       not all) of the squares. Your task is to subdivide the grid into
       rectangles of various sizes, such that (a) every rectangle contains
       exactly one numbered square, and (b) the area of each rectangle is
       equal to the number written in its numbered square.

       Credit for this game goes to the Japanese puzzle magazine Nikoli
       [3]; I've also seen a Palm implementation at Puzzle Palace [4].
       Unlike Puzzle Palace's implementation, my version automatically
       generates random grids of any size you like. The quality of puzzle
       design is therefore not quite as good as hand-crafted puzzles would
       be, but on the plus side you get an inexhaustible supply of puzzles
       tailored to your own specification.

       [3] http://www.nikoli.co.jp/puzzles/7/index_text-e.htm

       [4] http://www.puzzle.gr.jp/puzzle/sikaku/palm/index.html.en

   8.1 Rectangles controls

       This game is played with the mouse.

       Left-click any edge to toggle it on or off, or click and drag to
       draw an entire rectangle (or line) on the grid in one go (removing
       any existing edges within that rectangle).

       When a rectangle of the correct size is completed, it will be
       shaded.

       (All the actions described in section 2.1 are also available.)

   8.2 Rectangles parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid, in squares.

       _Expansion factor_

           This is a mechanism for changing the type of grids generated by
           the program. Some people prefer a grid containing a few large
           rectangles to one containing many small ones. So you can ask
           Rectangles to essentially generate a _smaller_ grid than the
           size you specified, and then to expand it by adding rows and
           columns.

           The default expansion factor of zero means that Rectangles will
           simply generate a grid of the size you ask for, and do nothing
           further. If you set an expansion factor of (say) 0.5, it means
           that each dimension of the grid will be expanded to half again
           as big after generation. In other words, the initial grid will
           be 2/3 the size in each dimension, and will be expanded to its
           full size without adding any more rectangles.

           Setting an expansion factor of around 0.5 tends to make the
           game more difficult, and also (in my experience) rewards a
           less deductive and more intuitive playing style. If you set it
           _too_ high, though, the game simply cannot generate more than a
           few rectangles to cover the entire grid, and the game becomes
           trivial.

       _Ensure unique solution_

           Normally, Rectangles will make sure that the puzzles it presents
           have only one solution. Puzzles with ambiguous sections can be
           more difficult and more subtle, so if you like you can turn off
           this feature and risk having ambiguous puzzles. Also, finding
           _all_ the possible solutions can be an additional challenge for
           an advanced player. Turning off this option can also speed up
           puzzle generation.

Chapter 9: Netslide
-------------------

       This game combines the grid generation of Net (see chapter 3) with
       the movement of Sixteen (see chapter 6): you have a Net grid, but
       instead of rotating tiles back into place you have to slide them
       into place by moving a whole row at a time.

       As in Sixteen, control is with the mouse. See section 6.1.

       The available game parameters have similar meanings to those in Net
       (see section 3.2) and Sixteen (see section 6.2).

       Netslide was contributed to this collection by Richard Boulton.

Chapter 10: Pattern
-------------------

       You have a grid of squares, which must all be filled in either black
       or white. Beside each row of the grid are listed the lengths of the
       runs of black squares on that row; above each column are listed the
       lengths of the runs of black squares in that column. Your aim is to
       fill in the entire grid black or white.

       I first saw this puzzle form around 1995, under the name
       `nonograms'. I've seen it in various places since then, under
       different names.

       Normally, puzzles of this type turn out to be a meaningful picture
       of something once you've solved them. However, since this version
       generates the puzzles automatically, they will just look like random
       groupings of squares. (One user has suggested that this is actually
       a _good_ thing, since it prevents you from guessing the colour of
       squares based on the picture, and forces you to use logic instead.)
       The advantage, though, is that you never run out of them.

  10.1 Pattern controls

       This game is played with the mouse.

       Left-click in a square to colour it black. Right-click to colour it
       white. If you make a mistake, you can middle-click, or hold down
       Shift while clicking with any button, to colour the square in the
       default grey (meaning `undecided') again.

       You can click and drag with the left or right mouse button to colour
       a vertical or horizontal line of squares black or white at a time
       (respectively). If you click and drag with the middle button, or
       with Shift held down, you can colour a whole rectangle of squares
       grey.

       (All the actions described in section 2.1 are also available.)

  10.2 Pattern parameters

       The only options available from the `Custom...' option on the `Type'
       menu are _Width_ and _Height_, which are self-explanatory.

Chapter 11: Solo
----------------

       You have a square grid, which is divided into square or rectangular
       blocks. Each square must be filled in with a digit from 1 to the
       size of the grid, in such a way that

        -  every row contains only one occurrence of each digit

        -  every column contains only one occurrence of each digit

        -  every block contains only one occurrence of each digit.

       You are given some of the numbers as clues; your aim is to place the
       rest of the numbers correctly.

       The default puzzle size is 3x3 (a 9x9 actual grid, divided into
       nine 3x3 blocks). You can also select sizes with rectangular blocks
       instead of square ones, such as 2x3 (a 6x6 grid divided into six 3x2
       blocks).

       If you select a puzzle size which requires more than 9 digits, the
       additional digits will be letters of the alphabet. For example, if
       you select 3x4 then the digits which go in your grid will be 1 to 9,
       plus `a', `b' and `c'.

       I first saw this puzzle in Nikoli [5], although it's also been
       popularised by various newspapers under the name `Sudoku' or `Su
       Doku'. Howard Garns is considered the inventor of the modern form of
       the puzzle, and it was first published in _Dell Pencil Puzzles and
       Word Games_. A more elaborate treatment of the history of the puzzle
       can be found on Wikipedia [6].

       [5] http://www.nikoli.co.jp/puzzles/1/index_text-e.htm

       [6] http://en.wikipedia.org/wiki/Sudoku

  11.1 Solo controls

       To play Solo, simply click the mouse in any empty square and then
       type a digit or letter on the keyboard to fill that square. If you
       make a mistake, click the mouse in the incorrect square and press
       Space to clear it again (or use the Undo feature).

       If you _right_-click in a square and then type a number, that number
       will be entered in the square as a `pencil mark'. You can have
       pencil marks for multiple numbers in the same square.

       The game pays no attention to pencil marks, so exactly what you
       use them for is up to you: you can use them as reminders that a
       particular square needs to be re-examined once you know more about
       a particular number, or you can use them as lists of the possible
       numbers in a given square, or anything else you feel like.

       To erase a single pencil mark, right-click in the square and type
       the same number again.

       All pencil marks in a square are erased when you left-click and type
       a number, or when you left-click and press space. Right-clicking and
       pressing space will also erase pencil marks.

       (All the actions described in section 2.1 are also available.)

  11.2 Solo parameters

       Solo allows you to configure two separate dimensions of the puzzle
       grid on the `Type' menu: the number of columns, and the number of
       rows, into which the main grid is divided. (The size of a block is
       the inverse of this: for example, if you select 2 columns and 3
       rows, each actual block will have 3 columns and 2 rows.)

       You can also configure the type of symmetry shown in the generated
       puzzles. More symmetry makes the puzzles look prettier but may also
       make them easier, since the symmetry constraints can force more
       clues than necessary to be present. Completely asymmetric puzzles
       have the freedom to contain as few clues as possible.

       Finally, you can configure the difficulty of the generated puzzles.
       Difficulty levels are judged by the complexity of the techniques
       of deduction required to solve the puzzle: each level requires a
       mode of reasoning which was not necessary in the previous one. In
       particular, on difficulty levels `Trivial' and `Basic' there will be
       a square you can fill in with a single number at all times, whereas
       at `Intermediate' level and beyond you will have to make partial
       deductions about the _set_ of squares a number could be in (or the
       set of numbers that could be in a square). At `Unreasonable' level,
       even this is not enough, and you will eventually have to make a
       guess, and then backtrack if it turns out to be wrong.

       Generating difficult puzzles is itself difficult: if you select one
       of the higher difficulty levels, Solo may have to make many attempts
       at generating a puzzle before it finds one hard enough for you. Be
       prepared to wait, especially if you have also configured a large
       puzzle size.

Chapter 12: Mines
-----------------

       You have a grid of covered squares, some of which contain mines, but
       you don't know which. Your job is to uncover every square which does
       _not_ contain a mine. If you uncover a square containing a mine, you
       lose. If you uncover a square which does not contain a mine, you
       are told how many mines are contained within the eight surrounding
       squares.

       This game needs no introduction; popularised by Windows, it is
       perhaps the single best known desktop puzzle game in existence.

       This version of it has an unusual property. By default, it will
       generate its mine positions in such a way as to ensure that you
       never need to _guess_ where a mine is: you will always be able
       to deduce it somehow. So you will never, as can happen in other
       versions, get to the last four squares and discover that there are
       two mines left but you have no way of knowing for sure where they
       are.

  12.1 Mines controls

       This game is played with the mouse.

       If you left-click in a covered square, it will be uncovered.

       If you right-click in a covered square, it will place a flag which
       indicates that the square is believed to be a mine. Left-clicking in
       a marked square will not uncover it, for safety. You can right-click
       again to remove a mark placed in error.

       If you left-click in an _uncovered_ square, it will `clear around'
       the square. This means: if the square has exactly as many flags
       surrounding it as it should have mines, then all the covered squares
       next to it which are _not_ flagged will be uncovered. So once you
       think you know the location of all the mines around a square, you
       can use this function as a shortcut to avoid having to click on each
       of the remaining squares one by one.

       If you uncover a square which has _no_ mines in the surrounding
       eight squares, then it is obviously safe to uncover those squares in
       turn, and so on if any of them also has no surrounding mines. This
       will be done for you automatically; so sometimes when you uncover a
       square, a whole new area will open up to be explored.

       All the actions described in section 2.1 are also available.

       Even Undo is available, although you might consider it cheating to
       use it. If you step on a mine, the program will only reveal the mine
       in question (unlike most other implementations, which reveal all of
       them). You can then Undo your fatal move and continue playing if you
       like. The program will track the number of times you died (and Undo
       will not reduce that counter), so when you get to the end of the
       game you know whether or not you did it without making any errors.

       (If you really want to know the full layout of the grid, which other
       implementations will show you after you die, you can always use the
       Solve menu option.)

  12.2 Mines parameters

       The options available from the `Custom...' option on the `Type' menu
       are:

       _Width_, _Height_

           Size of grid in squares.

       _Mines_

           Number of mines in the grid. You can enter this as an absolute
           mine count, or alternatively you can put a % sign on the end
           in which case the game will arrange for that proportion of the
           squares in the grid to be mines.

           Beware of setting the mine count too high. At very high
           densities, the program may spend forever searching for a
           solvable grid.

       _Ensure solubility_

           When this option is enabled (as it is by default), Mines will
           ensure that the entire grid can be fully deduced starting
           from the initial open space. If you prefer the riskier grids
           generated by other implementations, you can switch off this
           option.

Chapter 13: Same Game
---------------------

       You have a grid of coloured squares, which you have to clear by
       highlighting contiguous regions of more than one coloured square;
       the larger the region you highlight, the more points you get (and
       the faster you clear the arena).

       If you clear the grid you win. If you end up with nothing but single
       squares (i.e., there are no more clickable regions left) you lose.

       Removing a region causes the rest of the grid to shuffle up: blocks
       that are suspended will fall down (first), and then empty columns
       are filled from the right.

       Same Game was contributed to this collection by James Harvey.

  13.1 Same Game controls

       This game can be played with either the keyboard or the mouse.

       If you left-click an unselected region, it becomes selected
       (possibly clearing the current selection).

       If you left-click the selected region, it will be removed (and the
       rest of the grid shuffled immediately).

       If you right-click the selected region, it will be unselected.

       The cursor keys move a cursor around the grid. Pressing the Space or
       Enter keys while the cursor is in an unselected region selects it;
       pressing Space or Enter again removes it as above.

       (All the actions described in section 2.1 are also available.)

  13.2 Same Game parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

       _No. of colours_

           Number of different colours used to fill the grid; the more
           colours, the fewer large regions of colour and thus the more
           difficult it is to successfully clear the grid.

       _Scoring system_

           Controls the precise mechanism used for scoring. With the
           default system, `(n-2)^2', only regions of three squares or more
           will score any points at all. With the alternative `(n-1)^2'
           system, regions of two squares score a point each, and larger
           regions score relatively more points.

       _Ensure solubility_

           If this option is ticked (the default state), generated grids
           will be guaranteed to have at least one solution.

           If you turn it off, the game generator will not try to guarantee
           soluble grids; it will, however, still ensure that there are at
           least 2 squares of each colour on the grid at the start (since a
           grid with exactly one square of a given colour is _definitely_
           insoluble). Grids generated with this option disabled may
           contain more large areas of contiguous colour, leading to
           opportunities for higher scores; they can also take less time to
           generate.

Chapter 14: Flip
----------------

       You have a grid of squares, some light and some dark. Your aim is to
       light all the squares up at the same time. You can choose any square
       and flip its state from light to dark or dark to light, but when you
       do so, other squares around it change state as well.

       Each square contains a small diagram showing which other squares
       change when you flip it.

  14.1 Flip controls

       This game can be played with either the keyboard or the mouse.

       Left-click in a square to flip it and its associated squares, or use
       the cursor keys to choose a square and the space bar or Enter key to
       flip.

       If you use the `Solve' function on this game, it will mark some of
       the squares in red. If you click once in every square with a red
       mark, the game should be solved. (If you click in a square _without_
       a red mark, a red mark will appear in it to indicate that you will
       need to reverse that operation to reach the solution.)

       (All the actions described in section 2.1 are also available.)

  14.2 Flip parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

       _Shape type_

           This control determines the shape of the region which is flipped
           by clicking in any given square. The default setting, `Crosses',
           causes every square to flip itself and its four immediate
           neighbours (or three or two if it's at an edge or corner). The
           other setting, `Random', causes a random shape to be chosen for
           every square, so the game is different every time.

Chapter 15: Guess
-----------------

       You have a set of coloured pegs, and have to reproduce a
       predetermined sequence of them (chosen by the computer) within a
       certain number of guesses.

       Each guess gets marked with the number of correctly-coloured pegs
       in the correct places (in black), and also the number of correctly-
       coloured pegs in the wrong places (in white).

       This game is also known (and marketed, by Hasbro, mainly) as a board
       game `Mastermind', with 6 colours, 4 pegs per row, and 10 guesses.
       However, this version allows custom settings of number of colours
       (up to 10), number of pegs per row, and number of guesses.

       Guess was contributed to this collection by James Harvey.

  15.1 Guess controls

       This game can be played with either the keyboard or the mouse.

       With the mouse, drag a coloured peg from the tray on the left-hand
       side to its required position in the current guess; pegs may also
       be dragged from current and past guesses to copy them elsewhere. To
       remove a peg, drag it off its current position to somewhere invalid.

       Right-clicking in the current guess adds a `hold' marker; pegs that
       have hold markers will be automatically added to the next guess
       after marking.

       Alternatively, with the keyboard, the up and down cursor keys can
       be used to select a peg colour, the left and right keys to select a
       peg position, and the space bar or Enter key to place a peg of the
       selected colour in the chosen position. `D' or Backspace removes a
       peg, and `H' adds a hold marker.

       When the guess is complete, the smaller feedback pegs will be
       highlighted; clicking on these (or moving the peg cursor to them
       with the arrow keys and pressing the space bar or Enter key) will
       mark the current guess, copy any held pegs to the next guess, and
       move the `current guess' marker.

       If you correctly position all the pegs the solution will be
       displayed below; if you run out of guesses (or select `Solve...')
       the solution will also be revealed.

       (All the actions described in section 2.1 are also available.)

  15.2 Guess parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu. The default game matches the parameters for the board
       game `Mastermind'.

       _Colours_

           Number of colours the solution is chosen from; from 2 to 10
           (more is harder).

       _Pegs per guess_

           Number of pegs per guess (more is harder).

       _Guesses_

           Number of guesses you have to find the solution in (fewer is
           harder).

       _Allow blanks_

           Allows blank pegs to be given as part of a guess (makes it
           easier, because you know that those will never be counted as
           part of the solution). This is turned off by default.

       Note that this doesn't allow blank pegs in the solution; if you
       really wanted that, use one extra colour.

       _Allow duplicates_

           Allows the solution (and the guesses) to contain colours more
           than once; this increases the search space (making things
           harder), and is turned on by default.

Chapter 16: Pegs
----------------

       A number of pegs are placed in holes on a board. You can remove a
       peg by jumping an adjacent peg over it (horizontally or vertically)
       to a vacant hole on the other side. Your aim is to remove all but
       one of the pegs initially present.

       This game, best known as `Peg Solitaire', is possibly one of the
       oldest puzzle games still commonly known.

  16.1 Pegs controls

       To move a peg, drag it with the mouse from its current position to
       its final position. If the final position is exactly two holes away
       from the initial position, is currently unoccupied by a peg, and
       there is a peg in the intervening square, the move will be permitted
       and the intervening peg will be removed.

       Vacant spaces which you can move a peg into are marked with holes. A
       space with no peg and no hole is not available for moving at all: it
       is an obstacle which you must work around.

       (All the actions described in section 2.1 are also available.)

  16.2 Pegs parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in holes.

       _Board type_

           Controls whether you are given a board of a standard shape or
           a randomly generated shape. The two standard shapes currently
           supported are `Cross' and `Octagon' (also commonly known as the
           English and European traditional board layouts respectively).
           Selecting `Random' will give you a different board shape every
           time (but always one that is known to have a solution).

Chapter 17: Dominosa
--------------------

       A normal set of dominoes - that is, one instance of every
       (unordered) pair of numbers from 0 to 6 - has been arranged
       irregularly into a rectangle; then the number in each square has
       been written down and the dominoes themselves removed. Your task is
       to reconstruct the pattern by arranging the set of dominoes to match
       the provided array of numbers.

       This puzzle is widely credited to O. S. Adler, and takes part of its
       name from those initials.

  17.1 Dominosa controls

       Left-clicking between any two adjacent numbers places a domino
       covering them, or removes one if it is already present. Trying to
       place a domino which overlaps existing dominoes will remove the ones
       it overlaps.

       Right-clicking between two adjacent numbers draws a line between
       them, which you can use to remind yourself that you know those two
       numbers are _not_ covered by a single domino. Right-clicking again
       removes the line.

       (All the actions described in section 2.1 are also available.)

  17.2 Dominosa parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Maximum number on dominoes_

           Controls the size of the puzzle, by controlling the size of the
           set of dominoes used to make it. Dominoes with numbers going
           up to N will give rise to an (N+2) x (N+1) rectangle; so, in
           particular, the default value of 6 gives an 8x7 grid.

       _Ensure unique solution_

           Normally, Dominosa will make sure that the puzzles it presents
           have only one solution. Puzzles with ambiguous sections can be
           more difficult and sometimes more subtle, so if you like you
           can turn off this feature. Also, finding _all_ the possible
           solutions can be an additional challenge for an advanced player.
           Turning off this option can also speed up puzzle generation.

Chapter 18: Untangle
--------------------

       You are given a number of points, some of which have lines drawn
       between them. You can move the points about arbitrarily; your aim is
       to position the points so that no line crosses another.

       I originally saw this in the form of a Flash game called Planarity
       [7], written by John Tantalo.

       [7] http://home.cwru.edu/~jnt5/Planarity

  18.1 Untangle controls

       To move a point, click on it with the left mouse button and drag it
       into a new position.

       (All the actions described in section 2.1 are also available.)

  18.2 Untangle parameters

       There is only one parameter available from the `Custom...' option on
       the `Type' menu:

       _Number of points_

           Controls the size of the puzzle, by specifying the number of
           points in the generated graph.

Chapter 19: Black Box
---------------------

       A number of balls are hidden in a rectangular arena. You have to
       deduce the positions of the balls by firing lasers from positions on
       the edge of the arena and observing how they are deflected.

       Lasers will fire straight until they hit the opposite side of the
       arena (at which point they emerge), unless affected by balls in one
       of the following ways:

        -  A laser that hits a ball head-on is absorbed and will never re-
           emerge. This includes lasers that meet a ball on the first rank
           of the arena.

        -  A laser with a ball to its front-left square gets deflected 90
           degrees to the right.

        -  A laser with a ball to its front-right square gets similarly
           deflected to the left.

        -  A laser that would re-emerge from the entry location is
           considered to be `reflected'.

        -  A laser which would get deflected before entering the arena
           (down the `firing range') by a ball to the front-left or front-
           right of its entry point is also considered to be `reflected'.

       Lasers that are reflected appear as a `R'; lasers that hit balls
       dead-on appear as `H'. Otherwise, a number appears at the firing
       point and the location where the laser emerges (this number is
       unique to that shot).

       You can place guesses as to the location of the balls, based on the
       entry and exit patterns of the lasers; once you have placed enough
       balls a button appears enabling you to have your guesses checked.

       Here is a diagram showing how the positions of balls can create each
       of the laser behaviours shown above:

          1RHR---- 
         |..O.O...|
         2........3
         |........|
         |........|
         3........|
         |......O.|
         H........|
         |.....O..|
          12-RH---

       As shown, it is possible for a ball to receive multiple reflections
       before re-emerging (see turn 3). Similarly, a ball may be reflected
       (possibly more than once) before receiving a hit (the `H' on the
       left side of the example).

       Note that any layout with more that 4 balls may have a non-unique
       solution. The following diagram illustrates this; if you know the
       board contains 5 balls, it is impossible to determine where the
       fifth ball is (possible positions marked with an x):

          -------- 
         |........|
         |........|
         |..O..O..|
         |...xx...|
         |...xx...|
         |..O..O..|
         |........|
         |........|
          --------

       For this reason when you have your guesses checked the game will
       check that your solution _produces the same results_ as the
       computer's, rather than that your solution is identical to the
       computer's. So in the above example, you could put the fifth ball at
       _any_ of the locations marked with an x, and you would still win.

       Black Box was contributed to this collection by James Harvey.

  19.1 Black Box controls

       To fire a laser, left-click in a square around the side of the
       arena. The results will be displayed immediately. Lasers may not be
       fired twice (because the results will never change). Holding down
       the left button will highlight the current go (or a previous go) to
       confirm the exit point for that laser, if applicable.

       To guess the location of a ball, left-click within the arena and a
       black circle will appear marking the guess; to remove the guessed
       ball click again.

       Locations in the arena may be locked against modification by right-
       clicking; whole rows and columns may be similarly locked by right-
       clicking in the laser firing range above/below that column, or to
       the left/right of that row.

       When an appropriate number of balls have been guessed a button will
       appear at the top-left corner of the grid; clicking that will mark
       your guesses.

       If you click the `mark' button and your guesses are not correct, the
       game will show you as little information as possible to demonstrate
       this to you, so you can try again. If your ball positions are not
       consistent with the laser paths you already know about, one laser
       path will be circled to indicate that it proves you wrong. If your
       positions match all the existing laser paths but are still wrong,
       one new laser path will be revealed (written in red) which is not
       consistent with your current guesses.

       If you decide to give up completely, you can select Solve to reveal
       the actual ball positions. At this point, correctly-placed balls
       will be displayed as filled black circles; incorrectly-placed balls
       are displayed as filled black circles with red crosses, and missing
       balls are filled red circles. In addition, a red circle marks any
       laser you had already fired which is not consistent with your ball
       layout (just as when you press the mark button), and red text marks
       any laser you _could_ have fired in order to distinguish your ball
       layout from the right one.

       (All the actions described in section 2.1 are also available.)

  19.2 Black Box parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares. There are 2 x _Width_ x _Height_ lasers
           per grid, two per row and two per column.

       _No. of balls_

           Number of balls to place in the grid. This can be a single
           number, or a range (separated with a hyphen, like `2-6'),
           and determines the number of balls to place on the grid.
           The `reveal' button is only enabled if you have guessed an
           appropriate number of balls; a guess using a different number
           to the original solution is still acceptable, if all the laser
           inputs and outputs match.

Chapter 20: Slant
-----------------

       You have a grid of squares. Your aim is to draw a diagonal line
       through each square, and choose which way each line slants so that
       the following conditions are met:

        -  The diagonal lines never form a loop.

        -  Any point with a circled number has precisely that many lines
           meeting at it. (Thus, a 4 is the centre of a cross shape,
           whereas a zero is the centre of a diamond shape - or rather, a
           partial diamond shape, because a zero can never appear in the
           middle of the grid because that would immediately cause a loop.)

       Credit for this puzzle goes to Nikoli [8].

       [8] http://www.nikoli.co.jp/puzzles/39/index.htm (in Japanese)

  20.1 Slant controls

       Left-clicking in a blank square will place a \ in it (a line leaning
       to the left, i.e. running from the top left of the square to the
       bottom right). Right-clicking in a blank square will place a / in it
       (leaning to the right, running from top right to bottom left).

       Continuing to click either button will cycle between the three
       possible square contents. Thus, if you left-click repeatedly in a
       blank square it will change from blank to \ to / back to blank, and
       if you right-click repeatedly the square will change from blank to /
       to \ back to blank. (Therefore, you can play the game entirely with
       one button if you need to.)

       (All the actions described in section 2.1 are also available.)

  20.2 Slant parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

       _Difficulty_

           Controls the difficulty of the generated puzzle. At Hard
           level, you are required to do deductions based on knowledge of
           _relationships_ between squares rather than always being able to
           deduce the exact contents of one square at a time. (For example,
           you might know that two squares slant in the same direction,
           even if you don't yet know what that direction is, and this
           might enable you to deduce something about still other squares.)
           Even at Hard level, guesswork and backtracking should never be
           necessary.

Chapter 21: Light Up
--------------------

       You have a grid of squares. Some are filled in black; some of the
       black squares are numbered. Your aim is to `light up' all the empty
       squares by placing light bulbs in some of them.

       Each light bulb illuminates the square it is on, plus all squares
       in line with it horizontally or vertically unless a black square is
       blocking the way.

       To win the game, you must satisfy the following conditions:

        -  All non-black squares are lit.

        -  No light is lit by another light.

        -  All numbered black squares have exactly that number of lights
           adjacent to them (in the four squares above, below, and to the
           side).

       Non-numbered black squares may have any number of lights adjacent to
       them.

       Credit for this puzzle goes to Nikoli [9].

       Light Up was contributed to this collection by James Harvey.

       [9] http://www.nikoli.co.jp/puzzles/32/index-e.htm (beware of Flash)

  21.1 Light Up controls

       Left-clicking in a non-black square will toggle the presence of a
       light in that square. Right-clicking in a non-black square toggles a
       mark there to aid solving; it can be used to highlight squares that
       cannot be lit, for example.

       You may not place a light in a marked square, nor place a mark in a
       lit square.

       The game will highlight obvious errors in red. Lights lit by other
       lights are highlighted in this way, as are numbered squares which do
       not (or cannot) have the right number of lights next to them.

       Thus, the grid is solved when all non-black squares have yellow
       highlights and there are no red lights.

       (All the actions described in section 2.1 are also available.)

  21.2 Light Up parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

       _%age of black squares_

           Rough percentage of black squares in the grid.

           This is a hint rather than an instruction. If the grid generator
           is unable to generate a puzzle to this precise specification, it
           will increase the proportion of black squares until it can.

       _Symmetry_

           Allows you to specify the required symmetry of the black squares
           in the grid. (This does not affect the difficulty of the puzzles
           noticeably.)

       _Difficulty_

           `Easy' means that the puzzles should be soluble without
           backtracking or guessing, `Hard' means that some guesses will
           probably be necessary.

Chapter 22: Map
---------------

       You are given a map consisting of a number of regions. Your task is
       to colour each region with one of four colours, in such a way that
       no two regions sharing a boundary have the same colour. You are
       provided with some regions already coloured, sufficient to make the
       remainder of the solution unique.

       Only regions which share a length of border are required to be
       different colours. Two regions which meet at only one _point_ (i.e.
       are diagonally separated) may be the same colour.

       I believe this puzzle is original; I've never seen an implementation
       of it anywhere else. The concept of a four-colouring puzzle was
       suggested by Owen Dunn; credit must also go to Nikoli and to Verity
       Allan for inspiring the train of thought that led to me realising
       Owen's suggestion was a viable puzzle. Thanks also to Gareth Taylor
       for many detailed suggestions.

  22.1 Map controls

       To colour a region, click the left mouse button on an existing
       region of the desired colour and drag that colour into the new
       region.

       (The program will always ensure the starting puzzle has at least one
       region of each colour, so that this is always possible!)

       If you need to clear a region, you can drag from an empty region, or
       from the puzzle boundary if there are no empty regions left.

       Dragging a colour using the _right_ mouse button will stipple the
       region in that colour, which you can use as a note to yourself that
       you think the region _might_ be that colour. A region can contain
       stipples in multiple colours at once. (This is often useful at the
       harder difficulty levels.)

       If you press L during play, the game will toggle display of a number
       in each region of the map. This is useful if you want to discuss a
       particular puzzle instance with a friend - having an unambiguous
       name for each region is much easier than trying to refer to them all
       by names such as `the one down and right of the brown one on the top
       border'.

       (All the actions described in section 2.1 are also available.)

  22.2 Map parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

       _Regions_

           Number of regions in the generated map.

       _Difficulty_

           In `Easy' mode, there should always be at least one region whose
           colour can be determined trivially. In `Normal' and `Hard'
           modes, you will have to use increasingly complex logic to deduce
           the colour of some regions. However, it will always be possible
           without having to guess or backtrack.

           In `Unreasonable' mode, the program will feel free to generate
           puzzles which are as hard as it can possibly make them: the
           only constraint is that they should still have a unique
           solution. Solving Unreasonable puzzles may require guessing and
           backtracking.

Chapter 23: Loopy
-----------------

       You are given a grid of dots. Your aim is to draw a single unbroken
       loop from dot to dot within the grid.

       Some of the square spaces between the dots contain numbers. These
       numbers indicate how many of the four edges of that square are part
       of the loop. The loop you draw must correctly satisfy all of these
       clues to be considered a correct solution.

       Credit for this puzzle goes to Nikoli [10].

       Loopy was contributed to this collection by Mike Pinna.

       [10] http://www.nikoli.co.jp/puzzles/3/index-e.htm (beware of Flash)

  23.1 Loopy controls

       Click the left mouse button between two dots to add a line segment
       connecting them. Click again to remove that line segment.

       If you are sure that a particular line segment is _not_ part of the
       loop, you can click the right mouse button to add a small cross
       indicating this. Click again to remove the cross.

       (All the actions described in section 2.1 are also available.)

  23.2 Loopy parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

       _Difficulty_

           Controls the difficulty of the generated puzzle.

Chapter 24: Inertia
-------------------

       You are a small green ball sitting in a grid full of obstacles. Your
       aim is to collect all the gems without running into any mines.

       You can move the ball in any orthogonal _or diagonal_ direction.
       Once the ball starts moving, it will continue until something stops
       it. A wall directly in its path will stop it (but if it is moving
       diagonally, it will move through a diagonal gap between two other
       walls without stopping). Also, some of the squares are `stops'; when
       the ball moves on to a stop, it will stop moving no matter what
       direction it was going in. Gems do _not_ stop the ball; it picks
       them up and keeps on going.

       Running into a mine is fatal. Even if you picked up the last gem in
       the same move which then hit a mine, the game will count you as dead
       rather than victorious.

       This game was originally implemented for Windows by Ben Olmstead
       [11], who was kind enough to release his source code on request so
       that it could be re-implemented for this collection.

       [11] http://xn13.com/

  24.1 Inertia controls

       You can move the ball in any of the eight directions using the
       numeric keypad. Alternatively, if you click the left mouse button
       on the grid, the ball will begin a move in the general direction of
       where you clicked.

       If you use the `Solve' function on this game, the program will
       compute a path through the grid which collects all the remaining
       gems and returns to the current position. A hint arrow will appear
       on the ball indicating the direction in which you should move to
       begin on this path. If you then move in that direction, the arrow
       will update to indicate the next direction on the path. You can
       also press Space to automatically move in the direction of the hint
       arrow. If you move in a different direction from the one shown by
       the arrow, the hint arrows will stop appearing because you have
       strayed from the provided path; you can then use `Solve' again to
       generate a new path if you want to.

       All the actions described in section 2.1 are also available. In
       particular, if you do run into a mine and die, you can use the Undo
       function and resume playing from before the fatal move. The game
       will keep track of the number of times you have done this.

  24.2 Inertia parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

Chapter 25: Tents
-----------------

       You have a grid of squares, some of which contain trees. Your aim is
       to place tents in some of the remaining squares, in such a way that
       the following conditions are met:

        -  There are exactly as many tents as trees.

        -  The tents and trees can be matched up in such a way that each
           tent is directly adjacent (horizontally or vertically, but not
           diagonally) to its own tree. However, a tent may be adjacent to
           other trees as well as its own.

        -  No two tents are adjacent horizontally, vertically _or
           diagonally_.

        -  The number of tents in each row, and in each column, matches the
           numbers given round the sides of the grid.

       This puzzle can be found in several places on the Internet, and was
       brought to my attention by e-mail. I don't know who I should credit
       for inventing it.

  25.1 Tents controls

       Left-clicking in a blank square will place a tent in it. Right-
       clicking in a blank square will colour it green, indicating that you
       are sure it _isn't_ a tent. Clicking either button in an occupied
       square will clear it.

       If you _drag_ with the right button along a row or column, every
       blank square in the region you cover will be turned green, and no
       other squares will be affected. (This is useful for clearing the
       remainder of a row once you have placed all its tents.)

       (All the actions described in section 2.1 are also available.)

  25.2 Tents parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

       _Difficulty_

           Controls the difficulty of the generated puzzle. More difficult
           puzzles require more complex deductions, but at present none
           of the available difficulty levels requires guesswork or
           backtracking.

Chapter 26: Bridges
-------------------

       You have a set of islands distributed across the playing area.
       Each island contains a number. Your aim is to connect the islands
       together with bridges, in such a way that:

        -  Bridges run horizontally or vertically.

        -  The number of bridges terminating at any island is equal to the
           number written in that island.

        -  Two bridges may run in parallel between the same two islands,
           but no more than two may do so.

        -  No bridge crosses another bridge.

        -  All the islands are connected together.

       There are some configurable alternative modes, which involve
       changing the parallel-bridge limit to something other than 2, and
       introducing the additional constraint that no sequence of bridges
       may form a loop from one island back to the same island. The rules
       stated above are the default ones.

       Credit for this puzzle goes to Nikoli [12].

       Bridges was contributed to this collection by James Harvey.

       [12] http://www.nikoli.co.jp/puzzles/14/index-e.htm

  26.1 Bridges controls

       To place a bridge between two islands, click the mouse down on one
       island and drag it towards the other. You do not need to drag all
       the way to the other island; you only need to move the mouse far
       enough for the intended bridge direction to be unambiguous. (So you
       can keep the mouse near the starting island and conveniently throw
       bridges out from it in many directions.)

       Doing this again when a bridge is already present will add another
       parallel bridge. If there are already as many bridges between the
       two islands as permitted by the current game rules (i.e. two by
       default), the same dragging action will remove all of them.

       If you want to remind yourself that two islands definitely _do not_
       have a bridge between them, you can right-drag between them in the
       same way to draw a `non-bridge' marker.

       If you think you have finished with an island (i.e. you have placed
       all its bridges and are confident that they are in the right
       places), you can mark the island as finished by left-clicking on it.
       This will highlight it and all the bridges connected to it, and you
       will be prevented from accidentally modifying any of those bridges
       in future. Left-clicking again on a highlighted island will unmark
       it and restore your ability to modify it.

       Violations of the puzzle rules will be marked in red:

        -  An island with too many bridges will be highlighted in red.

        -  An island with too few bridges will be highlighted in red if it
           is definitely an error (as opposed to merely not being finished
           yet): if adding enough bridges would involve having to cross
           another bridge or remove a non-bridge marker, or if the island
           has been highlighted as complete.

        -  A group of islands and bridges may be highlighted in red if it
           is a closed subset of the puzzle with no way to connect it to
           the rest of the islands. For example, if you directly connect
           two 1s together with a bridge and they are not the only two
           islands on the grid, they will light up red to indicate that
           such a group cannot be contained in any valid solution.

        -  If you have selected the (non-default) option to disallow loops
           in the solution, a group of bridges which forms a loop will be
           highlighted.

       (All the actions described in section 2.1 are also available.)

  26.2 Bridges parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

       _Difficulty_

           Difficulty level of puzzle.

       _Allow loops_

           This is set by default. If cleared, puzzles will be generated in
           such a way that they are always soluble without creating a loop,
           and solutions which do involve a loop will be disallowed.

       _Max. bridges per direction_

           Maximum number of bridges in any particular direction. The
           default is 2, but you can change it to 1, 3 or 4. In general,
           fewer is easier.

       _%age of island squares_

           Gives a rough percentage of islands the generator will try and
           lay before finishing the puzzle. Certain layouts will not manage
           to lay enough islands; this is an upper bound.

       _Expansion factor (%age)_

           The grid generator works by picking an existing island at random
           (after first creating an initial island somewhere). It then
           decides on a direction (at random), and then works out how far
           it could extend before creating another island. This parameter
           determines how likely it is to extend as far as it can, rather
           than choosing somewhere closer.

       High expansion factors usually mean easier puzzles with fewer
       possible islands; low expansion factors can create lots of tightly-
       packed islands.

Chapter 27: Unequal
-------------------

       You have a square grid; each square may contain a digit from 1 to
       the size of the grid, and some squares have greater-than signs
       between them. Your aim is to fully populate the grid with numbers
       such that:

        -  Each row contains only one occurrence of each digit

        -  Each column contains only one occurrence of each digit

        -  All the greater-than signs are satisfied.

       In `Trivial' mode (available via the `Custom' game type selector),
       there are no greater-than signs; the puzzle is to solve the Latin
       square only.

       At the time of writing, this puzzle is appearing in the Guardian
       weekly under the name `Futoshiki'.

       Unequal was contributed to this collection by James Harvey.

  27.1 Unequal controls

       Unequal shares much of its control system with Solo.

       To play Unequal, simply click the mouse in any empty square and then
       type a digit or letter on the keyboard to fill that square. If you
       make a mistake, click the mouse in the incorrect square and press
       Space to clear it again (or use the Undo feature).

       If you _right_-click in a square and then type a number, that number
       will be entered in the square as a `pencil mark'. You can have
       pencil marks for multiple numbers in the same square.

       The game pays no attention to pencil marks, so exactly what you
       use them for is up to you: you can use them as reminders that a
       particular square needs to be re-examined once you know more about
       a particular number, or you can use them as lists of the possible
       numbers in a given square, or anything else you feel like.

       To erase a single pencil mark, right-click in the square and type
       the same number again.

       All pencil marks in a square are erased when you left-click and type
       a number, or when you left-click and press space. Right-clicking and
       pressing space will also erase pencil marks.

       (All the actions described in section 2.1 are also available.)

  27.2 Unequal parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Size (s*s)_

           Size of grid.

       _Difficulty_

           Controls the difficulty of the generated puzzle. At Trivial
           level, there are no greater-than signs; the puzzle is to solve
           the Latin square only. At Recursive level (only available via
           the `Custom' game type selector) backtracking will be required,
           but the solution should still be unique. The levels in between
           require increasingly complex reasoning to avoid having to
           backtrack.

Chapter 28: Galaxies
--------------------

       You have a rectangular grid containing a number of dots. Your aim is
       to draw edges along the grid lines which divide the rectangle into
       regions in such a way that every region is 180-degree rotationally
       symmetric, and contains exactly one dot which is located at its
       centre of symmetry.

       This puzzle was invented by Nikoli [13], under the name `Tentai
       Show'; its name is commonly translated into English as `Spiral
       Galaxies'.

       Galaxies was contributed to this collection by James Harvey.

       [13] http://www.nikoli.co.jp/en/puzzles/astronomical_show/

  28.1 Galaxies controls

       Left-click on any grid line to draw an edge if there isn't one
       already, or to remove one if there is. When you create a valid
       region (one which is closed, contains exactly one dot, is 180-degree
       symmetric about that dot, and contains no extraneous edges inside
       it) it will be highlighted automatically; so your aim is to have the
       whole grid highlighted in that way.

       During solving, you might know that a particular grid square belongs
       to a specific dot, but not be sure of where the edges go and which
       other squares are connected to the dot. In order to mark this so you
       don't forget, you can right-click on the dot and drag, which will
       create an arrow marker pointing at the dot. Drop that in a square of
       your choice and it will remind you which dot it's associated with.
       You can also right-click on existing arrows to pick them up and move
       them, or destroy them by dropping them off the edge of the grid.
       (Also, if you're not sure which dot an arrow is pointing at, you can
       pick it up and move it around to make it clearer. It will swivel
       constantly as you drag it, to stay pointed at its parent dot.)

       (All the actions described in section 2.1 are also available.)

  28.2 Galaxies parameters

       These parameters are available from the `Custom...' option on the
       `Type' menu.

       _Width_, _Height_

           Size of grid in squares.

       _Difficulty_

           Controls the difficulty of the generated puzzle. More difficult
           puzzles require more complex deductions, and the `Unreasonable'
           difficulty level may require backtracking.

Chapter 29: Filling
-------------------

       You have a grid of squares, some of which contain digits, and the
       rest of which are empty. Your job is to fill in digits in the empty
       squares, in such a way that each connected region of squares all
       containing the same digit has an area equal to that digit.

       (`Connected region', for the purposes of this game, does not count
       diagonally separated squares as adjacent.)

       For example, it follows that no square can contain a zero, and that
       two adjacent squares can not both contain a one. No region has an
       area greater than 9 (because then its area would not be a single
       digit).

       Credit for this puzzle goes to Nikoli [14].

       Filling was contributed to this collection by Jonas Koelker.

       [14] http://www.nikoli.co.jp/en/puzzles/fillomino/

  29.1 Filling controls

       To play Filling, simply click the mouse in any empty square and then
       type a digit on the keyboard to fill that square. If you make a
       mistake, click the mouse in the incorrect square and press 0, Space,
       Backspace or Enter to clear it again (or use the Undo feature).

       (All the actions described in section 2.1 are also available.)

  29.2 Filling parameters

       Filling allows you to configure the number of rows and columns of
       the grid, through the `Type' menu.

Appendix A: Licence
-------------------

       This software is copyright 2004-2007 Simon Tatham.

       Portions copyright Richard Boulton, James Harvey, Mike Pinna and
       Jonas Koelker.

       Permission is hereby granted, free of charge, to any person
       obtaining a copy of this software and associated documentation files
       (the `Software'), to deal in the Software without restriction,
       including without limitation the rights to use, copy, modify, merge,
       publish, distribute, sublicense, and/or sell copies of the Software,
       and to permit persons to whom the Software is furnished to do so,
       subject to the following conditions:

       The above copyright notice and this permission notice shall be
       included in all copies or substantial portions of the Software.

       THE SOFTWARE IS PROVIDED `AS IS', WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
       OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
       BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
       ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
       CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       SOFTWARE.

[$Id: puzzles.but 7336 2007-02-25 23:30:14Z simon $]
