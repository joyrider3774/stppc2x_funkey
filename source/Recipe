# -*- makefile -*-
# 
# This file describes which puzzle binaries are made up from which
# object and resource files. It is processed into the various
# Makefiles by means of a Perl script. Makefile changes should
# really be made by editing this file and/or the Perl script, not
# by editing the actual Makefiles.

!name puzzles

!makefile gtk Makefile
!makefile vc Makefile.vc
!makefile wce Makefile.wce
!makefile cygwin Makefile.cyg
!makefile osx Makefile.osx

!srcdir icons/

WINDOWS  = windows printing
         + user32.lib gdi32.lib comctl32.lib comdlg32.lib winspool.lib
COMMON   = midend drawing misc malloc random version
GTK      = gtk printing ps
# Objects needed for auxiliary command-line programs.
STANDALONE = nullfe random misc malloc

ALL      = list

# First half of list.c.
!begin >list.c
/*
 * list.c: List of pointers to puzzle structures, for monolithic
 * platforms.
 *
 * This file is automatically generated by mkfiles.pl. Do not edit
 * it directly, or the changes will be lost next time mkfiles.pl runs.
 * Instead, edit Recipe and/or its *.R subfiles.
 */
#include "puzzles.h"
#define GAMELIST(A) \
!end

# Now each .R file adds part of the macro definition of GAMELIST to list.c.
!include *.R

# Then we finish up list.c as follows:
!begin >list.c

#define DECL(x) extern const game x;
#define REF(x) &x,
GAMELIST(DECL)
const game *gamelist[] = { GAMELIST(REF) };
const int gamecount = lenof(gamelist);
!end

# Mac OS X unified application containing all the puzzles.
Puzzles  : [MX] osx osx.icns osx-info.plist COMMON ALL
# For OS X, we must create the online help and include it in the
# application bundle.) Also we add -DCOMBINED to the compiler flags
# so as to inform the code that we're building a single binary for
# all the puzzles. Then I've also got some code in here to build a
# distributable .dmg disk image.
!begin osx
CFLAGS += -DCOMBINED
Puzzles_extra = Puzzles.app/Contents/Resources/Help/index.html
Puzzles.app/Contents/Resources/Help/index.html: \
	Puzzles.app/Contents/Resources/Help osx-help.but puzzles.but
	cd Puzzles.app/Contents/Resources/Help; \
		halibut --html ../../../../osx-help.but ../../../../puzzles.but
Puzzles.app/Contents/Resources/Help: Puzzles.app/Contents/Resources
	mkdir -p Puzzles.app/Contents/Resources/Help

release: Puzzles.dmg
Puzzles.dmg: Puzzles
	rm -f raw.dmg
	hdiutil create -megabytes 5 -layout NONE raw.dmg
	hdid -nomount raw.dmg > devicename
	newfs_hfs -v "Simon Tatham's Puzzle Collection" `cat devicename`
	hdiutil eject `cat devicename`
	hdid raw.dmg | cut -f1 -d' ' > devicename
	cp -R Puzzles.app /Volumes/"Simon Tatham's Puzzle Collection"
	hdiutil eject `cat devicename`
	rm -f Puzzles.dmg
	hdiutil convert -format UDCO raw.dmg -o Puzzles.dmg
	rm -f raw.dmg devicename
!end

# Version management.
!begin vc
version.obj: *.c *.h
	cl $(VER) $(CFLAGS) /c version.c
!end
!specialobj vc version
!begin wce
version.obj: *.c *.h
	$(CC) $(VER) $(CFLAGS) /c version.c
!end
!specialobj wce version
!begin cygwin
version.o: FORCE;
FORCE:
	$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) $(VER) -c version.c
!end
!specialobj cygwin version
# For Unix, we also need the gross MD5 hack that causes automatic
# version number selection in release source archives.
!begin gtk
version.o: FORCE;
FORCE:
	if test -z "$(VER)" && test -f manifest && md5sum -c manifest; then \
		$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version.def` -c version.c; \
	elif test -z "$(VER)" && test -d .svn && svnversion . >/dev/null 2>&1; then \
		$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) "-DREVISION=`svnversion .`" -c version.c; \
	else \
		$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) $(VER) -c version.c; \
	fi
!end
!specialobj gtk version
# For OS X, this is made more fiddly by the fact that we don't have
# md5sum readily available. We do, however, have `md5 -r' which
# generates _nearly_ the same output, but it has no check function.
!begin osx
version.o: FORCE;
FORCE:
	if test -z "$(VER)" && test -f manifest && (md5 -r `awk '{print $$2}' manifest` | diff -w manifest -); then \
		$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version.def` -c version.c; \
	elif test -z "$(VER)" && test -d .svn && svnversion . >/dev/null 2>&1; then \
		$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) "-DREVISION=`svnversion .`" -c version.c; \
	else \
		$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) $(VER) -c version.c; \
	fi
!end
!specialobj osx version

# make install for Unix.
!begin gtk
install:
	for i in $(GAMES); do \
		$(INSTALL_PROGRAM) -m 755 $$i $(DESTDIR)$(gamesdir)/$$i \
		|| exit 1; \
	done
!end
