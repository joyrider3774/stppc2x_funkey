\title Simon Tatham's Portable Puzzle Collection

\cfg{winhelp-filename}{puzzles.hlp}
\cfg{winhelp-contents-titlepage}{Contents}

\cfg{text-filename}{puzzles.txt}

\cfg{html-contents-filename}{index.html}
\cfg{html-template-filename}{%k.html}
\cfg{html-index-filename}{docindex.html}
\cfg{html-leaf-level}{1}
\cfg{html-contents-depth-0}{1}
\cfg{html-contents-depth-1}{2}
\cfg{html-leaf-contains-contents}{true}

\cfg{info-filename}{puzzles.info}

\cfg{ps-filename}{puzzles.ps}
\cfg{pdf-filename}{puzzles.pdf}

\define{by} \u00D7{x}

\define{dash} \u2013{-}

This is a collection of small one-player puzzle games.

\copyright This manual is copyright 2004-2008 Simon Tatham. All rights
reserved. You may distribute this documentation under the MIT licence.
See \k{licence} for the licence text in full.

\cfg{html-local-head}{<meta name="AppleTitle" content="Puzzles Help">}

\versionid $Id: puzzles.but 7974 2008-04-07 15:56:42Z simon $

\C{intro} Introduction

I wrote this collection because I thought there should be more small
desktop toys available: little games you can pop up in a window and
play for two or three minutes while you take a break from whatever
else you were doing. And I was also annoyed that every time I found
a good game on (say) \i{Unix}, it wasn't available the next time I
was sitting at a \i{Windows} machine, or vice versa; so I arranged
that everything in my personal puzzle collection will happily run on
both, and have more recently done a port to \i{Mac OS X} as well. When I
find (or perhaps invent) further puzzle games that I like, they'll
be added to this collection and will immediately be available on
both platforms. And if anyone feels like writing any other front
ends \dash PocketPC, Mac OS pre-10, or whatever it might be \dash
then all the games in this framework will immediately become
available on another platform as well.

The actual games in this collection were mostly not my invention; they
are re-implementations of existing game concepts within my portable
puzzle framework. I do not claim credit, in general, for inventing the
rules of any of these puzzles. (I don't even claim authorship of all
the code; some of the puzzles have been submitted by other authors.)

This collection is distributed under the \i{MIT licence} (see
\k{licence}). This means that you can do pretty much anything you like
with the game binaries or the code, except pretending you wrote them
yourself, or suing me if anything goes wrong. 

The most recent versions, and \i{source code}, can be found at
\I{website}\W{http://www.chiark.greenend.org.uk/~sgtatham/puzzles/}\cw{http://www.chiark.greenend.org.uk/~sgtatham/puzzles/}.

Please report \I{feedback}\i{bugs} to
\W{mailto:anakin@pobox.com}\cw{anakin@pobox.com}.
You might find it helpful to read this article before reporting a bug:

\W{http://www.chiark.greenend.org.uk/~sgtatham/bugs.html}\cw{http://www.chiark.greenend.org.uk/~sgtatham/bugs.html}

\ii{Patches} are welcome. Especially if they provide a new front end
(to make all these games run on another platform), or a new game.


\C{common} \ii{Common features}

This chapter describes features that are common to all the games.

\H{common-actions} \I{controls}Common actions

These actions are all available from the \I{Game menu}\q{Game} menu
and via \I{keys}keyboard shortcuts, in addition to any game-specific
actions.

(On \i{Mac OS X}, to conform with local user interface standards, these
actions are situated on the \I{File menu}\q{File} and \I{Edit
menu}\q{Edit} menus instead.)

\dt \ii\e{New game} (\q{N}, Ctrl+\q{N})

\dd Starts a new game, with a random initial state.

\dt \ii\e{Restart game}

\dd Resets the current game to its initial state. (This can be undone.)

\dt \ii\e{Load}

\dd Loads a saved game from a file on disk.

\dt \ii\e{Save}

\dd Saves the current state of your game to a file on disk.

\lcont{

The Load and Save operations preserve your entire game
history (so you can save, reload, and still Undo and Redo things you
had done before saving).

}

\dt \I{printing, on Windows}\e{Print}

\dd Where supported (currently only on Windows), brings up a dialog
allowing you to print an arbitrary number of puzzles randomly
generated from the current parameters, optionally including the
current puzzle. (Only for puzzles which make sense to print, of
course - it's hard to think of a sensible printable representation
of Fifteen!)

\dt \ii\e{Undo} (\q{U}, Ctrl+\q{Z}, Ctrl+\q{_})

\dd Undoes a single move. (You can undo moves back to the start of the
session.)

\dt \ii\e{Redo} (\q{R}, Ctrl+\q{R})

\dd Redoes a previously undone move.

\dt \ii\e{Copy}

\dd Copies the current state of your game to the clipboard in text
format, so that you can paste it into (say) an e-mail client or a
web message board if you're discussing the game with someone else.
(Not all games support this feature.)

\dt \ii\e{Solve}

\dd Transforms the puzzle instantly into its solved state. For some
games (Cube) this feature is not supported at all because it is of
no particular use. For other games (such as Pattern), the solved
state can be used to give you information, if you can't see how a
solution can exist at all or you want to know where you made a
mistake. For still other games (such as Sixteen), automatic solution
tells you nothing about how to \e{get} to the solution, but it does
provide a useful way to get there quickly so that you can experiment
with set-piece moves and transformations.

\lcont{

Some games (such as Solo) are capable of solving a game ID you have
typed in from elsewhere. Other games (such as Rectangles) cannot
solve a game ID they didn't invent themself, but when they did
invent the game ID they know what the solution is already. Still
other games (Pattern) can solve \e{some} external game IDs, but only
if they aren't too difficult.

The \q{Solve} command adds the solved state to the end of the undo
chain for the puzzle. In other words, if you want to go back to
solving it yourself after seeing the answer, you can just press Undo.

}

\dt \I{exit}\ii\e{Quit} (\q{Q}, Ctrl+\q{Q})

\dd Closes the application entirely.

\H{common-id} Specifying games with the \ii{game ID}

There are two ways to save a game specification out of a puzzle and
recreate it later, or recreate it in somebody else's copy of the
same puzzle.

The \q{\i{Specific}} and \q{\i{Random Seed}} options from the
\I{Game menu}\q{Game} menu (or the \q{File} menu, on \i{Mac OS X}) each
show a piece of text (a \q{game ID}) which is sufficient to
reconstruct precisely the same game at a later date.

You can enter either of these pieces of text back into the program
(via the same \q{Specific} or \q{Random Seed} menu options) at a
later point, and it will recreate the same game. You can also use
either one as a \i{command line} argument (on Windows or Unix); see
\k{common-cmdline} for more detail.

The difference between the two forms is that a descriptive game ID
is a literal \e{description} of the \i{initial state} of the game,
whereas a random seed is just a piece of arbitrary text which was
provided as input to the random number generator used to create the
puzzle. This means that:

\b Descriptive game IDs tend to be longer in many puzzles (although
some, such as Cube (\k{cube}), only need very short descriptions).
So a random seed is often a \e{quicker} way to note down the puzzle
you're currently playing, or to tell it to somebody else so they can
play the same one as you.

\b Any text at all is a valid random seed. The automatically
generated ones are fifteen-digit numbers, but anything will do; you
can type in your full name, or a word you just made up, and a valid
puzzle will be generated from it. This provides a way for two or
more people to race to complete the same puzzle: you think of a
random seed, then everybody types it in at the same time, and nobody
has an advantage due to having seen the generated puzzle before
anybody else.

\b It is often possible to convert puzzles from other sources (such
as \q{nonograms} or \q{sudoku} from newspapers) into descriptive
game IDs suitable for use with these programs.

\b Random seeds are not guaranteed to produce the same result if you
use them with a different \i\e{version} of the puzzle program. This
is because the generation algorithm might have been improved or
modified in later versions of the code, and will therefore produce a
different result when given the same sequence of random numbers. Use
a descriptive game ID if you aren't sure that it will be used on the
same version of the program as yours.

\lcont{(Use the \q{About} menu option to find out the version number
of the program. Programs with the same version number running on
different platforms should still be random-seed compatible.)}

\I{ID format}A descriptive game ID starts with a piece of text which
encodes the \i\e{parameters} of the current game (such as grid
size). Then there is a colon, and after that is the description of
the game's initial state. A random seed starts with a similar string
of parameters, but then it contains a hash sign followed by
arbitrary data.

If you enter a descriptive game ID, the program will not be able to
show you the random seed which generated it, since it wasn't
generated \e{from} a random seed. If you \e{enter} a random seed,
however, the program will be able to show you the descriptive game
ID derived from that random seed.

Note that the game parameter strings are not always identical
between the two forms. For some games, there will be parameter data
provided with the random seed which is not included in the
descriptive game ID. This is because that parameter information is
only relevant when \e{generating} puzzle grids, and is not important
when playing them. Thus, for example, the difficulty level in Solo
(\k{solo}) is not mentioned in the descriptive game ID.

These additional parameters are also not set permanently if you type
in a game ID. For example, suppose you have Solo set to \q{Advanced}
difficulty level, and then a friend wants your help with a
\q{Trivial} puzzle; so the friend reads out a random seed specifying
\q{Trivial} difficulty, and you type it in. The program will
generate you the same \q{Trivial} grid which your friend was having
trouble with, but once you have finished playing it, when you ask
for a new game it will automatically go back to the \q{Advanced}
difficulty which it was previously set on.

\H{common-type} The \q{Type} menu

The \I{Type menu}\q{Type} menu, if present, may contain a list of
\i{preset} game settings. Selecting one of these will start a new
random game with the parameters specified.

The \q{Type} menu may also contain a \q{\i{Custom}} option which
allows you to fine-tune game \i{parameters}. The parameters
available are specific to each game and are described in the
following sections.

\H{common-cmdline} Specifying game parameters on the \i{command line}

(This section does not apply to the \i{Mac OS X} version.)

The games in this collection deliberately do not ever save
information on to the computer they run on: they have no high score
tables and no saved preferences. (This is because I expect at least
some people to play them at work, and those people will probably
appreciate leaving as little evidence as possible!)

However, if you do want to arrange for one of these games to
\I{default parameters, specifying}default to a particular set of
parameters, you can specify them on the command line.

The easiest way to do this is to set up the parameters you want
using the \q{Type} menu (see \k{common-type}), and then to select
\q{Random Seed} from the \q{Game} or \q{File} menu (see
\k{common-id}). The text in the \q{Game ID} box will be composed of
two parts, separated by a hash. The first of these parts represents
the game parameters (the size of the playing area, for example, and
anything else you set using the \q{Type} menu).

If you run the game with just that parameter text on the command
line, it will start up with the settings you specified.

For example: if you run Cube (see \k{cube}), select \q{Octahedron}
from the \q{Type} menu, and then go to the game ID selection, you
will see a string of the form \cq{o2x2#338686542711620}. Take only
the part before the hash (\cq{o2x2}), and start Cube with that text
on the command line: \cq{cube o2x2}.

If you copy the \e{entire} game ID on to the command line, the game
will start up in the specific game that was described. This is
occasionally a more convenient way to start a particular game ID
than by pasting it into the game ID selection box.

(You could also retrieve the encoded game parameters using the
\q{Specific} menu option instead of \q{Random Seed}, but if you do
then some options, such as the difficulty level in Solo, will be
missing. See \k{common-id} for more details on this.)

\H{common-unix-cmdline} \i{Unix} \i{command-line} options

(This section only applies to the Unix port.)

In addition to being able to specify game parameters on the command
line (see \k{common-cmdline}), there are various other options:

\dt \cw{--game}

\dt \cw{--load}

\dd These options respectively determine whether the command-line
argument is treated as specifying game parameters or a \i{save} file
to \i{load}. Only one should be specified. If neither of these options
is specified, a guess is made based on the format of the argument.

\dt \cw{--generate }\e{n}

\dd If this option is specified, instead of a puzzle being displayed,
a number of descriptive game IDs will be \I{generating game IDs}invented
and printed on standard output. This is useful for gaining access to
the game generation algorithms without necessarily using the frontend.

\lcont{

If game parameters are specified on the command-line, they will be
used to generate the game IDs; otherwise a default set of parameters
will be used.

The most common use of this option is in conjunction with \c{--print},
in which case its behaviour is slightly different; see below.

}

\dt \I{printing, on Unix}\cw{--print }\e{w}\cw{x}\e{h}

\dd If this option is specified, instead of a puzzle being displayed,
a printed representation of one or more unsolved puzzles is sent to
standard output, in \i{PostScript} format.

\lcont{

On each page of puzzles, there will be \e{w} across and \e{h} down. If
there are more puzzles than \e{w}\by\e{h}, more than one page will be
printed.

If \c{--generate} has also been specified, the invented game IDs will
be used to generate the printed output. Otherwise, a list of game IDs
is expected on standard input (which can be descriptive or random
seeds; see \k{common-id}), in the same format produced by
\c{--generate}.

For example:

\c net --generate 12 --print 2x3 7x7w | lpr

will generate two pages of printed Net puzzles (each of which will
have a 7\by\.7 wrapping grid), and pipe the output to the \c{lpr}
command, which on many systems will send them to an actual printer.

There are various other options which affect printing; see below.

}

\dt \cw{--version}

\dd Prints version information about the game, and then quits.

The following options are only meaningful if \c{--print} is also
specified:

\dt \cw{--with-solutions}

\dd The set of pages filled with unsolved puzzles will be followed by
the solutions to those puzzles.

\dt \cw{--scale }\e{n}

\dd Adjusts how big each puzzle is when printed. Larger numbers make
puzzles bigger; the default is 1.0.

\dt \cw{--colour}

\dd Puzzles will be printed in colour, rather than in black and white
(if supported by the puzzle).


\C{net} \i{Net}

\cfg{winhelp-topic}{games.net}

(\e{Note:} the \i{Windows} version of this game is called
\i\cw{NETGAME.EXE} to avoid clashing with Windows's own \cw{NET.EXE}.)

I originally saw this in the form of a Flash game called \i{FreeNet}
\k{FreeNet}, written by Pavils Jurjans; there are several other
implementations under the name \i{NetWalk}. The computer prepares a
network by connecting up the centres of squares in a grid, and then
shuffles the network by rotating every tile randomly. Your job is to
rotate it all back into place. The successful solution will be an
entirely connected network, with no closed loops. \#{The latter
clause means that there are no closed paths within the network.
Could this be clearer? "No closed paths"?} As a visual aid,
all tiles which are connected to the one in the middle are
highlighted. 

\B{FreeNet} \W{http://www.jurjans.lv/stuff/net/FreeNet.htm}\cw{http://www.jurjans.lv/stuff/net/FreeNet.htm}

\H{net-controls} \i{Net controls}

\IM{Net controls} controls, for Net
\IM{Net controls} keys, for Net
\IM{Net controls} shortcuts (keyboard), for Net

This game can be played with either the keyboard or the mouse. The
controls are:

\dt \e{Select tile}: mouse pointer, arrow keys

\dt \e{Rotate tile anticlockwise}: left mouse button, \q{A} key

\dt \e{Rotate tile clockwise}: right mouse button, \q{D} key

\dt \e{Rotate tile by 180 degrees}: \q{F} key

\dt \e{Lock (or unlock) tile}: middle mouse button, shift-click, \q{S} key

\dd You can lock a tile once you're sure of its orientation. You can
also unlock it again, but while it's locked you can't accidentally
turn it.

The following controls are not necessary to complete the game, but may
be useful:

\dt \e{Shift grid}: Shift + arrow keys

\dd On grids that wrap, you can move the origin of the grid, so that
tiles that were on opposite sides of the grid can be seen together.

\dt \e{Move centre}: Ctrl + arrow keys

\dd You can change which tile is used as the source of highlighting.
(It doesn't ultimately matter which tile this is, as every tile will
be connected to every other tile in a correct solution, but it may be
helpful in the intermediate stages of solving the puzzle.)

\dt \e{Jumble tiles}: \q{J} key

\dd This key turns all tiles that are not locked to random
orientations.

(All the actions described in \k{common-actions} are also available.)

\H{net-params} \I{parameters, for Net}Net parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in tiles.

\dt \e{Walls wrap around}

\dd If checked, flow can pass from the left edge to the right edge,
and from top to bottom, and vice versa.

\dt \e{Barrier probability}

\dd A number between 0.0 and 1.0 controlling whether an immovable
barrier is placed between two tiles to prevent flow between them (a
higher number gives more barriers). Since barriers are immovable, they
act as constraints on the solution (i.e., hints).

\lcont{

The grid generation in Net has been carefully arranged so that the
barriers are independent of the rest of the grid. This means that if
you note down the random seed used to generate the current puzzle
(see \k{common-id}), change the \e{Barrier probability} parameter,
and then re-enter the same random seed, you should see exactly the
same starting grid, with the only change being the number of
barriers. So if you're stuck on a particular grid and need a hint,
you could start up another instance of Net, set up the same
parameters but a higher barrier probability, and enter the game seed
from the original Net window.

}

\dt \e{Ensure unique solution}

\dd Normally, Net will make sure that the puzzles it presents have
only one solution. Puzzles with ambiguous sections can be more
difficult and more subtle, so if you like you can turn off this
feature and risk having ambiguous puzzles. (Also, finding \e{all}
the possible solutions can be an additional challenge for an
advanced player.)


\C{cube} \i{Cube}

\cfg{winhelp-topic}{games.cube}

This is another one I originally saw as a web game. This one was a
Java game \k{cube-java-game}, by Paul Scott. You have a grid of 16
squares, six of which are blue; on one square rests a cube. Your move
is to use the arrow keys to roll the cube through 90 degrees so that
it moves to an adjacent square. If you roll the cube on to a blue
square, the blue square is picked up on one face of the cube; if you
roll a blue face of the cube on to a non-blue square, the blueness is
put down again. (In general, whenever you roll the cube, the two faces
that come into contact swap colours.) Your job is to get all six blue
squares on to the six faces of the cube at the same time. Count your
moves and try to do it in as few as possible. 

Unlike the original Java game, my version has an additional feature:
once you've mastered the game with a cube rolling on a square grid,
you can change to a triangular grid and roll any of a tetrahedron, an
octahedron or an icosahedron. 

\B{cube-java-game} \W{http://www3.sympatico.ca/paulscott/cube/cube.htm}\cw{http://www3.sympatico.ca/paulscott/cube/cube.htm}

\H{cube-controls} \i{Cube controls}

\IM{Cube controls} controls, for Cube
\IM{Cube controls} keys, for Cube
\IM{Cube controls} shortcuts (keyboard), for Cube

This game can be played with either the keyboard or the mouse.

Left-clicking anywhere on the window will move the cube (or other
solid) towards the mouse pointer.

The arrow keys can also used to roll the cube on its square grid in
the four cardinal directions.
On the triangular grids, the mapping of arrow keys to directions is
more approximate. Vertical movement is disallowed where it doesn't
make sense. The four keys surrounding the arrow keys on the numeric
keypad (\q{7}, \q{9}, \q{1}, \q{3}) can be used for diagonal movement.

(All the actions described in \k{common-actions} are also available.)

\H{cube-params} \I{parameters, for Cube}Cube parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Type of solid}

\dd Selects the solid to roll (and hence the shape of the grid):
tetrahedron, cube, octahedron, or icosahedron.

\dt \e{Width / top}, \e{Height / bottom}

\dd On a square grid, horizontal and vertical dimensions. On a
triangular grid, the number of triangles on the top and bottom rows
respectively.


\C{fifteen} \i{Fifteen}

\cfg{winhelp-topic}{games.fifteen}

The old ones are the best: this is the good old \q{\i{15-puzzle}}
with sliding tiles. You have a 4\by\.4 square grid; 15 squares
contain numbered tiles, and the sixteenth is empty. Your move is to
choose a tile next to the empty space, and slide it into the space.
The aim is to end up with the tiles in numerical order, with the
space in the bottom right (so that the top row reads 1,2,3,4 and the
bottom row reads 13,14,15,\e{space}).

\H{fifteen-controls} \i{Fifteen controls}

\IM{Fifteen controls} controls, for Fifteen
\IM{Fifteen controls} keys, for Fifteen
\IM{Fifteen controls} shortcuts (keyboard), for Fifteen

This game can be controlled with the mouse or the keyboard.

A left-click with the mouse in the row or column containing the empty
space will move as many tiles as necessary to move the space to the
mouse pointer.

The arrow keys will move a tile adjacent to the space in the direction
indicated (moving the space in the \e{opposite} direction).

(All the actions described in \k{common-actions} are also available.)

\H{fifteen-params} \I{parameters, for Fifteen}Fifteen parameters

The only options available from the \q{Custom...} option on the \q{Type}
menu are \e{Width} and \e{Height}, which are self-explanatory. (Once
you've changed these, it's not a \q{15-puzzle} any more, of course!)


\C{sixteen} \i{Sixteen}

\cfg{winhelp-topic}{games.sixteen}

Another sliding tile puzzle, visually similar to Fifteen (see
\k{fifteen}) but with a different type of move. This time, there is no
hole: all 16 squares on the grid contain numbered squares. Your move
is to shift an entire row left or right, or shift an entire column up
or down; every time you do that, the tile you shift off the grid
re-appears at the other end of the same row, in the space you just
vacated. To win, arrange the tiles into numerical order (1,2,3,4 on
the top row, 13,14,15,16 on the bottom). When you've done that, try
playing on different sizes of grid. 

I \e{might} have invented this game myself, though only by accident if
so (and I'm sure other people have independently invented it). I
thought I was imitating a screensaver I'd seen, but I have a feeling
that the screensaver might actually have been a Fifteen-type puzzle
rather than this slightly different kind. So this might be the one
thing in my puzzle collection which represents creativity on my part
rather than just engineering.

\H{sixteen-controls} \I{controls, for Sixteen}Sixteen controls

This game is played with the mouse. Left-clicking on an arrow will
move the appropriate row or column in the direction indicated.
Right-clicking will move it in the opposite direction.

(All the actions described in \k{common-actions} are also available.)

\H{sixteen-params} \I{parameters, for Sixteen}Sixteen parameters

The parameters available from the \q{Custom...} option on the
\q{Type} menu are:

\b \e{Width} and \e{Height}, which are self-explanatory.

\b You can ask for a limited shuffling operation to be performed on
the grid. By default, Sixteen will shuffle the grid in such a way
that any arrangement is about as probable as any other. You can
override this by requesting a precise number of shuffling moves to
be performed. Typically your aim is then to determine the precise
set of shuffling moves and invert them exactly, so that you answer
(say) a four-move shuffle with a four-move solution. Note that the
more moves you ask for, the more likely it is that solutions shorter
than the target length will turn out to be possible.


\C{twiddle} \i{Twiddle}

\cfg{winhelp-topic}{games.twiddle}

Twiddle is a tile-rearrangement puzzle, visually similar to Sixteen
(see \k{sixteen}): you are given a grid of square tiles, each
containing a number, and your aim is to arrange the numbers into
ascending order.

In basic Twiddle, your move is to rotate a square group of four
tiles about their common centre. (Orientation is not significant in
the basic puzzle, although you can select it.) On more advanced
settings, you can rotate a larger square group of tiles.

I first saw this type of puzzle in the GameCube game \q{Metroid
Prime 2}. In the Main Gyro Chamber in that game, there is a puzzle
you solve to unlock a door, which is a special case of Twiddle. I
developed this game as a generalisation of that puzzle.

\H{twiddle-controls} \I{controls, for Twiddle}Twiddle controls

To play Twiddle, click the mouse in the centre of the square group
you wish to rotate. In the basic mode, you rotate a 2\by\.2 square,
which means you have to click at a corner point where four tiles
meet.

In more advanced modes you might be rotating 3\by\.3 or even more at
a time; if the size of the square is odd then you simply click in
the centre tile of the square you want to rotate.

Clicking with the left mouse button rotates the group anticlockwise.
Clicking with the right button rotates it clockwise.

(All the actions described in \k{common-actions} are also available.)

\H{twiddle-parameters} \I{parameters, for Twiddle}Twiddle parameters

Twiddle provides several configuration options via the \q{Custom}
option on the \q{Type} menu:

\b You can configure the width and height of the puzzle grid.

\b You can configure the size of square block that rotates at a time.

\b You can ask for every square in the grid to be distinguishable
(the default), or you can ask for a simplified puzzle in which there
are groups of identical numbers. In the simplified puzzle your aim
is just to arrange all the 1s into the first row, all the 2s into
the second row, and so on.

\b You can configure whether the orientation of tiles matters. If
you ask for an orientable puzzle, each tile will have a triangle
drawn in it. All the triangles must be pointing upwards to complete
the puzzle.

\b You can ask for a limited shuffling operation to be performed on
the grid. By default, Twiddle will shuffle the grid so much that any
arrangement is about as probable as any other. You can override this
by requesting a precise number of shuffling moves to be performed.
Typically your aim is then to determine the precise set of shuffling
moves and invert them exactly, so that you answer (say) a four-move
shuffle with a four-move solution. Note that the more moves you ask
for, the more likely it is that solutions shorter than the target
length will turn out to be possible.


\C{rectangles} \i{Rectangles}

\cfg{winhelp-topic}{games.rectangles}

You have a grid of squares, with numbers written in some (but not all)
of the squares. Your task is to subdivide the grid into rectangles of
various sizes, such that (a) every rectangle contains exactly one
numbered square, and (b) the area of each rectangle is equal to the
number written in its numbered square.

Credit for this game goes to the Japanese puzzle magazine \i{Nikoli}
\k{nikoli-rect}; I've also seen a Palm implementation at \i{Puzzle
Palace} \k{puzzle-palace-rect}. Unlike Puzzle Palace's
implementation, my version automatically generates random grids of
any size you like. The quality of puzzle design is therefore not
quite as good as hand-crafted puzzles would be, but on the plus side
you get an inexhaustible supply of puzzles tailored to your own
specification.

\B{nikoli-rect} \W{http://www.nikoli.co.jp/puzzles/7/index_text-e.htm}\cw{http://www.nikoli.co.jp/puzzles/7/index_text-e.htm}

\B{puzzle-palace-rect} \W{http://www.puzzle.gr.jp/puzzle/sikaku/palm/index.html.en}\cw{http://www.puzzle.gr.jp/puzzle/sikaku/palm/index.html.en}

\H{rectangles-controls} \I{controls, for Rectangles}Rectangles controls

This game is played with the mouse.

Left-click any edge to toggle it on or off, or click and drag to draw
an entire rectangle (or line) on the grid in one go (removing any
existing edges within that rectangle).

When a rectangle of the correct size is completed, it will be shaded.

(All the actions described in \k{common-actions} are also available.)

\H{rectangles-params} \I{parameters, for Rectangles}Rectangles parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid, in squares.

\dt \e{Expansion factor}

\dd This is a mechanism for changing the type of grids generated by
the program. Some people prefer a grid containing a few large
rectangles to one containing many small ones. So you can ask
Rectangles to essentially generate a \e{smaller} grid than the size
you specified, and then to expand it by adding rows and columns.

\lcont{

The default expansion factor of zero means that Rectangles will
simply generate a grid of the size you ask for, and do nothing
further. If you set an expansion factor of (say) 0.5, it means that
each dimension of the grid will be expanded to half again as big
after generation. In other words, the initial grid will be 2/3 the
size in each dimension, and will be expanded to its full size
without adding any more rectangles.

Setting an expansion factor of around 0.5 tends to make the game
more difficult, and also (in my experience) rewards a less deductive
and more intuitive playing style. If you set it \e{too} high,
though, the game simply cannot generate more than a few rectangles
to cover the entire grid, and the game becomes trivial.

}

\dt \e{Ensure unique solution}

\dd Normally, Rectangles will make sure that the puzzles it presents
have only one solution. Puzzles with ambiguous sections can be more
difficult and more subtle, so if you like you can turn off this
feature and risk having ambiguous puzzles. Also, finding \e{all} the
possible solutions can be an additional challenge for an advanced
player. Turning off this option can also speed up puzzle generation.


\C{netslide} \i{Netslide}

\cfg{winhelp-topic}{games.netslide}

This game combines the grid generation of Net (see \k{net}) with the
movement of Sixteen (see \k{sixteen}): you have a Net grid, but
instead of rotating tiles back into place you have to slide them
into place by moving a whole row at a time. 

As in Sixteen, \I{controls, for Netslide}control is with the mouse.
See \k{sixteen-controls}.

\I{parameters, for Netslide}The available game parameters have similar
meanings to those in Net (see \k{net-params}) and Sixteen (see
\k{sixteen-params}).

Netslide was contributed to this collection by Richard Boulton.


\C{pattern} \i{Pattern}

\cfg{winhelp-topic}{games.pattern}

You have a grid of squares, which must all be filled in either black
or white. Beside each row of the grid are listed the lengths of the
runs of black squares on that row; above each column are listed the
lengths of the runs of black squares in that column. Your aim is to
fill in the entire grid black or white.

I first saw this puzzle form around 1995, under the name
\q{\i{nonograms}}. I've seen it in various places since then, under
different names.

Normally, puzzles of this type turn out to be a meaningful picture
of something once you've solved them. However, since this version
generates the puzzles automatically, they will just look like random
groupings of squares. (One user has suggested that this is actually
a \e{good} thing, since it prevents you from guessing the colour of
squares based on the picture, and forces you to use logic instead.)
The advantage, though, is that you never run out of them.

\H{pattern-controls} \I{controls, for Pattern}Pattern controls

This game is played with the mouse.

Left-click in a square to colour it black. Right-click to colour it
white. If you make a mistake, you can middle-click, or hold down
Shift while clicking with any button, to colour the square in the
default grey (meaning \q{undecided}) again.

You can click and drag with the left or right mouse button to colour
a vertical or horizontal line of squares black or white at a time
(respectively). If you click and drag with the middle button, or
with Shift held down, you can colour a whole rectangle of squares
grey.

(All the actions described in \k{common-actions} are also available.)

\H{pattern-parameters} \I{parameters, for Pattern}Pattern parameters

The only options available from the \q{Custom...} option on the \q{Type}
menu are \e{Width} and \e{Height}, which are self-explanatory.


\C{solo} \i{Solo}

\cfg{winhelp-topic}{games.solo}

You have a square grid, which is divided into square or rectangular
blocks. Each square must be filled in with a digit from 1 to the
size of the grid, in such a way that

\b every row contains only one occurrence of each digit

\b every column contains only one occurrence of each digit

\b every block contains only one occurrence of each digit.

You are given some of the numbers as clues; your aim is to place the
rest of the numbers correctly.

The default puzzle size is 3\by\.3 (a 9\by\.9 actual grid, divided
into nine 3\by\.3 blocks). You can also select sizes with
rectangular blocks instead of square ones, such as 2\by\.3 (a
6\by\.6 grid divided into six 3\by\.2 blocks).

If you select a puzzle size which requires more than 9 digits, the
additional digits will be letters of the alphabet. For example, if
you select 3\by\.4 then the digits which go in your grid will be 1
to 9, plus \cq{a}, \cq{b} and \cq{c}.

I first saw this puzzle in \i{Nikoli} \k{nikoli-solo}, although it's
also been popularised by various newspapers under the name
\q{Sudoku} or \q{Su Doku}.  Howard Garns is considered the inventor
of the modern form of the puzzle, and it was first published in
\e{Dell Pencil Puzzles and Word Games}.  A more elaborate treatment
of the history of the puzzle can be found on Wikipedia
\k{wikipedia-solo}.

\B{nikoli-solo} \W{http://www.nikoli.co.jp/puzzles/1/index_text-e.htm}\cw{http://www.nikoli.co.jp/puzzles/1/index_text-e.htm}

\B{wikipedia-solo} \W{http://en.wikipedia.org/wiki/Sudoku}\cw{http://en.wikipedia.org/wiki/Sudoku}

\H{solo-controls} \I{controls, for Solo}Solo controls

To play Solo, simply click the mouse in any empty square and then
type a digit or letter on the keyboard to fill that square. If you
make a mistake, click the mouse in the incorrect square and press
Space to clear it again (or use the Undo feature).

If you \e{right}-click in a square and then type a number, that
number will be entered in the square as a \q{pencil mark}. You can
have pencil marks for multiple numbers in the same square.

The game pays no attention to pencil marks, so exactly what you use
them for is up to you: you can use them as reminders that a
particular square needs to be re-examined once you know more about a
particular number, or you can use them as lists of the possible
numbers in a given square, or anything else you feel like.

To erase a single pencil mark, right-click in the square and type
the same number again.

All pencil marks in a square are erased when you left-click and type
a number, or when you left-click and press space. Right-clicking and
pressing space will also erase pencil marks.

(All the actions described in \k{common-actions} are also available.)

\H{solo-parameters} \I{parameters, for Solo}Solo parameters

Solo allows you to configure two separate dimensions of the puzzle
grid on the \q{Type} menu: the number of columns, and the number of
rows, into which the main grid is divided. (The size of a block is
the inverse of this: for example, if you select 2 columns and 3 rows,
each actual block will have 3 columns and 2 rows.)

You can introduce an optional extra constraint on the puzzles,
requiring that the two main diagonals of the grid also contain one
of every digit. (This is sometimes known as \q{Sudoku-X} in
newspapers.) In this mode, the squares on the two main diagonals
will be shaded slightly so that you know it's enabled.

You can also configure the type of symmetry shown in the generated
puzzles. More symmetry makes the puzzles look prettier but may also
make them easier, since the symmetry constraints can force more
clues than necessary to be present. Completely asymmetric puzzles
have the freedom to contain as few clues as possible.

Finally, you can configure the difficulty of the generated puzzles.
Difficulty levels are judged by the complexity of the techniques of
deduction required to solve the puzzle: each level requires a mode
of reasoning which was not necessary in the previous one. In
particular, on difficulty levels \q{Trivial} and \q{Basic} there
will be a square you can fill in with a single number at all times,
whereas at \q{Intermediate} level and beyond you will have to make
partial deductions about the \e{set} of squares a number could be in
(or the set of numbers that could be in a square).
\#{Advanced, Extreme?}
At \q{Unreasonable} level, even this is not enough, and you will
eventually have to make a guess, and then backtrack if it turns out
to be wrong.

Generating difficult puzzles is itself difficult: if you select one
of the higher difficulty levels, Solo may have to make many attempts
at generating a puzzle before it finds one hard enough for you. Be
prepared to wait, especially if you have also configured a large
puzzle size.


\C{mines} \i{Mines}

\cfg{winhelp-topic}{games.mines}

You have a grid of covered squares, some of which contain mines, but
you don't know which. Your job is to uncover every square which does
\e{not} contain a mine. If you uncover a square containing a mine,
you lose. If you uncover a square which does not contain a mine, you
are told how many mines are contained within the eight surrounding
squares.

This game needs no introduction; popularised by Windows, it is
perhaps the single best known desktop puzzle game in existence.

This version of it has an unusual property. By default, it will
generate its mine positions in such a way as to ensure that you
never need to \e{guess} where a mine is: you will always be able to
deduce it somehow. So you will never, as can happen in other
versions, get to the last four squares and discover that there are
two mines left but you have no way of knowing for sure where they
are.

\H{mines-controls} \I{controls, for Mines}Mines controls

This game is played with the mouse.

If you left-click in a covered square, it will be uncovered.

If you right-click in a covered square, it will place a flag which
indicates that the square is believed to be a mine. Left-clicking in
a marked square will not uncover it, for safety. You can right-click
again to remove a mark placed in error.

If you left-click in an \e{uncovered} square, it will \q{clear
around} the square. This means: if the square has exactly as many
flags surrounding it as it should have mines, then all the covered
squares next to it which are \e{not} flagged will be uncovered. So
once you think you know the location of all the mines around a
square, you can use this function as a shortcut to avoid having to
click on each of the remaining squares one by one.

If you uncover a square which has \e{no} mines in the surrounding
eight squares, then it is obviously safe to uncover those squares in
turn, and so on if any of them also has no surrounding mines. This
will be done for you automatically; so sometimes when you uncover a
square, a whole new area will open up to be explored.

All the actions described in \k{common-actions} are also available.

Even Undo is available, although you might consider it cheating to
use it. If you step on a mine, the program will only reveal the mine
in question (unlike most other implementations, which reveal all of
them). You can then Undo your fatal move and continue playing if you
like. The program will track the number of times you died (and Undo
will not reduce that counter), so when you get to the end of the
game you know whether or not you did it without making any errors.

(If you really want to know the full layout of the grid, which other
implementations will show you after you die, you can always use the
Solve menu option.)

\H{mines-parameters} \I{parameters, for Mines}Mines parameters

The options available from the \q{Custom...} option on the \q{Type}
menu are:

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{Mines}

\dd Number of mines in the grid. You can enter this as an absolute
mine count, or alternatively you can put a \cw{%} sign on the end in
which case the game will arrange for that proportion of the squares
in the grid to be mines.

\lcont{

Beware of setting the mine count too high. At very high densities,
the program may spend forever searching for a solvable grid.

}

\dt \e{Ensure solubility}

\dd When this option is enabled (as it is by default), Mines will
ensure that the entire grid can be fully deduced starting from the
initial open space. If you prefer the riskier grids generated by
other implementations, you can switch off this option.


\C{samegame} \i{Same Game}

\cfg{winhelp-topic}{games.samegame}

You have a grid of coloured squares, which you have to clear by 
highlighting contiguous regions of more than one coloured square;
the larger the region you highlight, the more points you get (and
the faster you clear the arena).

If you clear the grid you win. If you end up with nothing but 
single squares (i.e., there are no more clickable regions left) you
lose.

Removing a region causes the rest of the grid to shuffle up:
blocks that are suspended will fall down (first), and then empty
columns are filled from the right. 

Same Game was contributed to this collection by James Harvey.

\H{samegame-controls} \i{Same Game controls}

\IM{Same Game controls} controls, for Same Game
\IM{Same Game controls} keys, for Same Game
\IM{Same Game controls} shortcuts (keyboard), for Same Game

This game can be played with either the keyboard or the mouse.

If you left-click an unselected region, it becomes selected (possibly
clearing the current selection). 

If you left-click the selected region, it will be removed (and the
rest of the grid shuffled immediately).

If you right-click the selected region, it will be unselected. 

The cursor keys move a cursor around the grid. Pressing the Space or
Enter keys while the cursor is in an unselected region selects it;
pressing Space or Enter again removes it as above.

(All the actions described in \k{common-actions} are also available.)

\H{samegame-parameters} \I{parameters, for Same Game}Same Game parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{No. of colours}

\dd Number of different colours used to fill the grid; the more colours,
the fewer large regions of colour and thus the more difficult it is to
successfully clear the grid.

\dt \e{Scoring system}

\dd Controls the precise mechanism used for scoring. With the default
system, \q{(n-2)^2}, only regions of three squares or more will score
any points at all. With the alternative \q{(n-1)^2} system, regions of
two squares score a point each, and larger regions score relatively
more points.

\dt \e{Ensure solubility}

\dd If this option is ticked (the default state), generated grids
will be guaranteed to have at least one solution.

\lcont{

If you turn it off, the game generator will not try to guarantee
soluble grids; it will, however, still ensure that there are at
least 2 squares of each colour on the grid at the start (since a
grid with exactly one square of a given colour is \e{definitely}
insoluble). Grids generated with this option disabled may contain
more large areas of contiguous colour, leading to opportunities for
higher scores; they can also take less time to generate.

}


\C{flip} \i{Flip}

\cfg{winhelp-topic}{games.flip}

You have a grid of squares, some light and some dark. Your aim is to
light all the squares up at the same time. You can choose any square
and flip its state from light to dark or dark to light, but when you
do so, other squares around it change state as well.

Each square contains a small diagram showing which other squares
change when you flip it.

\H{flip-controls} \i{Flip controls}

\IM{Flip controls} controls, for Flip
\IM{Flip controls} keys, for Flip
\IM{Flip controls} shortcuts (keyboard), for Flip

This game can be played with either the keyboard or the mouse.

Left-click in a square to flip it and its associated squares, or
use the cursor keys to choose a square and the space bar or Enter
key to flip.

If you use the \q{Solve} function on this game, it will mark some of
the squares in red. If you click once in every square with a red
mark, the game should be solved. (If you click in a square
\e{without} a red mark, a red mark will appear in it to indicate
that you will need to reverse that operation to reach the solution.)

(All the actions described in \k{common-actions} are also available.)

\H{flip-parameters} \I{parameters, for flip}Flip parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{Shape type}

\dd This control determines the shape of the region which is flipped
by clicking in any given square. The default setting, \q{Crosses},
causes every square to flip itself and its four immediate neighbours
(or three or two if it's at an edge or corner). The other setting,
\q{Random}, causes a random shape to be chosen for every square, so
the game is different every time.


\C{guess} \i{Guess}

\cfg{winhelp-topic}{games.guess}

You have a set of coloured pegs, and have to reproduce a
predetermined sequence of them (chosen by the computer) within a
certain number of guesses. 

Each guess gets marked with the number of correctly-coloured pegs
in the correct places (in black), and also the number of
correctly-coloured pegs in the wrong places (in white). 

This game is also known (and marketed, by Hasbro, mainly) as
a board game \q{\i{Mastermind}}, with 6 colours, 4 pegs per row,
and 10 guesses. However, this version allows custom settings of number
of colours (up to 10), number of pegs per row, and number of guesses. 

Guess was contributed to this collection by James Harvey.

\H{guess-controls} \i{Guess controls}

\IM{Guess controls} controls, for Guess
\IM{Guess controls} keys, for Guess
\IM{Guess controls} shortcuts (keyboard), for Guess

This game can be played with either the keyboard or the mouse.

With the mouse, drag a coloured peg from the tray on the left-hand
side to its required position in the current guess; pegs may also be
dragged from current and past guesses to copy them elsewhere. To
remove a peg, drag it off its current position to somewhere invalid.

Right-clicking in the current guess adds a \q{hold} marker; pegs
that have hold markers will be automatically added to the next guess
after marking.

Alternatively, with the keyboard, the up and down cursor keys can be
used to select a peg colour, the left and right keys to select a
peg position, and the space bar or Enter key to place a peg of the
selected colour in the chosen position. \q{D} or Backspace removes a
peg, and \q{H} adds a hold marker.

When the guess is complete, the smaller feedback pegs will be highlighted;
clicking on these (or moving the peg cursor to them with the arrow keys
and pressing the space bar or Enter key) will mark the current guess,
copy any held pegs to the next guess, and move the \q{current guess}
marker.

If you correctly position all the pegs the solution will be displayed
below; if you run out of guesses (or select \q{Solve...}) the solution
will also be revealed.

(All the actions described in \k{common-actions} are also available.)

\H{guess-parameters} \I{parameters, for Guess}Guess parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu. The default game matches the parameters for the 
board game \q{Mastermind}. 

\dt \e{Colours}

\dd Number of colours the solution is chosen from; from 2 to 10
(more is harder).

\dt \e{Pegs per guess}

\dd Number of pegs per guess (more is harder).

\dt \e{Guesses}

\dd Number of guesses you have to find the solution in (fewer is harder).

\dt \e{Allow blanks}

\dd Allows blank pegs to be given as part of a guess (makes it easier, because
you know that those will never be counted as part of the solution). This
is turned off by default. 

Note that this doesn't allow blank pegs in the solution; if you really wanted
that, use one extra colour.

\dt \e{Allow duplicates}

\dd Allows the solution (and the guesses) to contain colours more than once;
this increases the search space (making things harder), and is turned on by
default.


\C{pegs} \i{Pegs}

\cfg{winhelp-topic}{games.pegs}

A number of pegs are placed in holes on a board. You can remove a
peg by jumping an adjacent peg over it (horizontally or vertically)
to a vacant hole on the other side. Your aim is to remove all but one
of the pegs initially present.

This game, best known as \I{Solitaire, Peg}\q{Peg Solitaire}, is
possibly one of the oldest puzzle games still commonly known.

\H{pegs-controls} \i{Pegs controls}

\IM{Pegs controls} controls, for Pegs

To move a peg, drag it with the mouse from its current position to
its final position. If the final position is exactly two holes away
from the initial position, is currently unoccupied by a peg, and
there is a peg in the intervening square, the move will be permitted
and the intervening peg will be removed.

Vacant spaces which you can move a peg into are marked with holes. A
space with no peg and no hole is not available for moving at all: it
is an obstacle which you must work around.

(All the actions described in \k{common-actions} are also available.)

\H{pegs-parameters} \I{parameters, for Pegs}Pegs parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in holes.

\dt \e{Board type}

\dd Controls whether you are given a board of a standard shape or a
randomly generated shape. The two standard shapes currently
supported are \q{Cross} and \q{Octagon} (also commonly known as the
English and European traditional board layouts respectively).
Selecting \q{Random} will give you a different board shape every
time (but always one that is known to have a solution).


\C{dominosa} \i{Dominosa}

\cfg{winhelp-topic}{games.dominosa}

A normal set of dominoes \dash that is, one instance of every
(unordered) pair of numbers from 0 to 6 \dash has been arranged
irregularly into a rectangle; then the number in each square has
been written down and the dominoes themselves removed. Your task is
to reconstruct the pattern by arranging the set of dominoes to match
the provided array of numbers.

This puzzle is widely credited to O. S. Adler, and takes part of its
name from those initials.

\H{dominosa-controls} \i{Dominosa controls}

\IM{Dominosa controls} controls, for Dominosa

Left-clicking between any two adjacent numbers places a domino
covering them, or removes one if it is already present. Trying to
place a domino which overlaps existing dominoes will remove the ones
it overlaps.

Right-clicking between two adjacent numbers draws a line between
them, which you can use to remind yourself that you know those two
numbers are \e{not} covered by a single domino. Right-clicking again
removes the line.

(All the actions described in \k{common-actions} are also available.)

\H{dominosa-parameters} \I{parameters, for Dominosa}Dominosa parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Maximum number on dominoes}

\dd Controls the size of the puzzle, by controlling the size of the
set of dominoes used to make it. Dominoes with numbers going up to N
will give rise to an (N+2) \by (N+1) rectangle; so, in particular,
the default value of 6 gives an 8\by\.7 grid.

\dt \e{Ensure unique solution}

\dd Normally, Dominosa will make sure that the puzzles it presents
have only one solution. Puzzles with ambiguous sections can be more
difficult and sometimes more subtle, so if you like you can turn off
this feature. Also, finding \e{all} the possible solutions can be an
additional challenge for an advanced player. Turning off this option
can also speed up puzzle generation.


\C{untangle} \i{Untangle}

\cfg{winhelp-topic}{games.untangle}

You are given a number of points, some of which have lines drawn
between them. You can move the points about arbitrarily; your aim is
to position the points so that no line crosses another.

I originally saw this in the form of a Flash game called \i{Planarity}
\k{Planarity}, written by John Tantalo.

\B{Planarity} \W{http://home.cwru.edu/~jnt5/Planarity}\cw{http://home.cwru.edu/~jnt5/Planarity}

\H{untangle-controls} \i{Untangle controls}

\IM{Untangle controls} controls, for Untangle

To move a point, click on it with the left mouse button and drag it
into a new position.

(All the actions described in \k{common-actions} are also available.)

\H{untangle-parameters} \I{parameters, for Untangle}Untangle parameters

There is only one parameter available from the \q{Custom...} option
on the \q{Type} menu:

\dt \e{Number of points}

\dd Controls the size of the puzzle, by specifying the number of
points in the generated graph.


\C{blackbox} \i{Black Box}

\cfg{winhelp-topic}{games.blackbox}

A number of balls are hidden in a rectangular arena. You have to 
deduce the positions of the balls by firing lasers from positions
on the edge of the arena and observing how they are deflected. 

Lasers will fire straight until they hit the opposite side of the
arena (at which point they emerge), unless affected by balls in one of
the following ways:

\b A laser that hits a ball head-on is absorbed and will never re-emerge.
   This includes lasers that meet a ball on the first rank of the arena.

\b A laser with a ball to its front-left square gets deflected 90 degrees
   to the right.

\b A laser with a ball to its front-right square gets similarly deflected 
   to the left. 

\b A laser that would re-emerge from the entry location is considered to be
   \q{reflected}. 

\b A laser which would get deflected before entering the arena (down the
   \q{firing range}) by a ball to the front-left or front-right of its
   entry point is also considered to be \q{reflected}.

Lasers that are reflected appear as a \q{R}; lasers that hit balls
dead-on appear as \q{H}. Otherwise, a number appears at the firing point
and the location where the laser emerges (this number is unique to
that shot).

You can place guesses as to the location of the balls, based on the
entry and exit patterns of the lasers; once you have placed enough
balls a button appears enabling you to have your guesses checked. 

Here is a diagram showing how the positions of balls can create each
of the laser behaviours shown above:

\c  1RHR---- 
\c |..O.O...|
\c 2........3
\c |........|
\c |........|
\c 3........|
\c |......O.|
\c H........|
\c |.....O..|
\c  12-RH---

As shown, it is possible for a ball to receive multiple reflections
before re-emerging (see turn 3). Similarly, a ball may be reflected
(possibly more than once) before receiving a hit (the \q{H} on the
left side of the example).

Note that any layout with more that 4 balls may have a non-unique
solution.  The following diagram illustrates this; if you know the
board contains 5 balls, it is impossible to determine where the fifth
ball is (possible positions marked with an x):

\c  -------- 
\c |........|
\c |........|
\c |..O..O..|
\c |...xx...|
\c |...xx...|
\c |..O..O..|
\c |........|
\c |........|
\c  --------

For this reason when you have your guesses checked the game will
check that your solution \e{produces the same results} as the
computer's, rather than that your solution is identical to the
computer's. So in the above example, you could put the fifth ball at
\e{any} of the locations marked with an x, and you would still win.

Black Box was contributed to this collection by James Harvey.

\H{blackbox-controls} \i{Black Box controls}

\IM{Black Box controls}controls, for Black Box

To fire a laser, left-click in a square around the side of the arena.
The results will be displayed immediately. Lasers may not be fired
twice (because the results will never change). Holding down the left
button will highlight the current go (or a previous go) to confirm the
exit point for that laser, if applicable.

To guess the location of a ball, left-click within the arena and a
black circle will appear marking the guess; to remove the guessed ball
click again. 

Locations in the arena may be locked against modification by
right-clicking; whole rows and columns may be similarly locked by
right-clicking in the laser firing range above/below that column, or
to the left/right of that row.  

When an appropriate number of balls have been guessed a button will
appear at the top-left corner of the grid; clicking that will mark
your guesses. 

If you click the \q{mark} button and your guesses are not correct,
the game will show you as little information as possible to
demonstrate this to you, so you can try again. If your ball
positions are not consistent with the laser paths you already know
about, one laser path will be circled to indicate that it proves you
wrong. If your positions match all the existing laser paths but are
still wrong, one new laser path will be revealed (written in red)
which is not consistent with your current guesses.

If you decide to give up completely, you can select Solve to reveal
the actual ball positions. At this point, correctly-placed balls
will be displayed as filled black circles; incorrectly-placed balls
are displayed as filled black circles with red crosses, and missing
balls are filled red circles. In addition, a red circle marks any
laser you had already fired which is not consistent with your ball
layout (just as when you press the mark button), and red text marks
any laser you \e{could} have fired in order to distinguish your ball
layout from the right one.

(All the actions described in \k{common-actions} are also available.)

\H{blackbox-parameters} \I{parameters, for Black Box}Black Box parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares. There are 2 \by \e{Width} \by \e{Height} lasers 
per grid, two per row and two per column. 

\dt \e{No. of balls}

\dd Number of balls to place in the grid. This can be a single number,
or a range (separated with a hyphen, like \q{2-6}), and determines the
number of balls to place on the grid. The \q{reveal} button is only
enabled if you have guessed an appropriate number of balls; a guess
using a different number to the original solution is still acceptable,
if all the laser inputs and outputs match.


\C{slant} \i{Slant}

\cfg{winhelp-topic}{games.slant}

You have a grid of squares. Your aim is to draw a diagonal line
through each square, and choose which way each line slants so that
the following conditions are met:

\b The diagonal lines never form a loop.

\b Any point with a circled number has precisely that many lines
meeting at it. (Thus, a 4 is the centre of a cross shape, whereas a
zero is the centre of a diamond shape \dash or rather, a partial
diamond shape, because a zero can never appear in the middle of the
grid because that would immediately cause a loop.)

Credit for this puzzle goes to \i{Nikoli} \k{nikoli-slant}.

\B{nikoli-slant}
\W{http://www.nikoli.co.jp/puzzles/39/index.htm}\cw{http://www.nikoli.co.jp/puzzles/39/index.htm}
(in Japanese)

\H{slant-controls} \i{Slant controls}

\IM{Slant controls} controls, for Slant

Left-clicking in a blank square will place a \cw{\\} in it (a line
leaning to the left, i.e. running from the top left of the square to
the bottom right). Right-clicking in a blank square will place a
\cw{/} in it (leaning to the right, running from top right to bottom
left).

Continuing to click either button will cycle between the three
possible square contents. Thus, if you left-click repeatedly in a
blank square it will change from blank to \cw{\\} to \cw{/} back to
blank, and if you right-click repeatedly the square will change from
blank to \cw{/} to \cw{\\} back to blank. (Therefore, you can play
the game entirely with one button if you need to.)

(All the actions described in \k{common-actions} are also available.)

\H{slant-parameters} \I{parameters, for Slant}Slant parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{Difficulty}

\dd Controls the difficulty of the generated puzzle. At Hard level,
you are required to do deductions based on knowledge of
\e{relationships} between squares rather than always being able to
deduce the exact contents of one square at a time. (For example, you
might know that two squares slant in the same direction, even if you
don't yet know what that direction is, and this might enable you to
deduce something about still other squares.) Even at Hard level,
guesswork and backtracking should never be necessary.


\C{lightup} \i{Light Up}

\cfg{winhelp-topic}{games.lightup}

You have a grid of squares. Some are filled in black; some of the
black squares are numbered. Your aim is to \q{light up} all the
empty squares by placing light bulbs in some of them.

Each light bulb illuminates the square it is on, plus all squares in
line with it horizontally or vertically unless a black square is
blocking the way.

To win the game, you must satisfy the following conditions:

\b All non-black squares are lit.

\b No light is lit by another light.

\b All numbered black squares have exactly that number of lights adjacent to
   them (in the four squares above, below, and to the side).

Non-numbered black squares may have any number of lights adjacent to them. 

Credit for this puzzle goes to \i{Nikoli} \k{nikoli-lightup}.

Light Up was contributed to this collection by James Harvey.

\B{nikoli-lightup}
\W{http://www.nikoli.co.jp/puzzles/32/index-e.htm}\cw{http://www.nikoli.co.jp/puzzles/32/index-e.htm}
(beware of Flash)

\H{lightup-controls} \i{Light Up controls}

\IM{Light Up controls} controls, for Light Up

Left-clicking in a non-black square will toggle the presence of a light
in that square. Right-clicking in a non-black square toggles a mark there to aid
solving; it can be used to highlight squares that cannot be lit, for example. 

You may not place a light in a marked square, nor place a mark in a lit square.

The game will highlight obvious errors in red. Lights lit by other
lights are highlighted in this way, as are numbered squares which
do not (or cannot) have the right number of lights next to them.
  
Thus, the grid is solved when all non-black squares have yellow
highlights and there are no red lights.

(All the actions described in \k{common-actions} are also available.)

\H{lightup-parameters} \I{parameters, for Light Up}Light Up parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{%age of black squares}

\dd Rough percentage of black squares in the grid.

\lcont{

This is a hint rather than an instruction. If the grid generator is
unable to generate a puzzle to this precise specification, it will
increase the proportion of black squares until it can.

}

\dt \e{Symmetry}

\dd Allows you to specify the required symmetry of the black squares
in the grid. (This does not affect the difficulty of the puzzles
noticeably.)

\dt \e{Difficulty}

\dd \q{Easy} means that the puzzles should be soluble without
backtracking or guessing, \q{Hard} means that some guesses will
probably be necessary.


\C{map} \i{Map}

\cfg{winhelp-topic}{games.map}

You are given a map consisting of a number of regions. Your task is
to colour each region with one of four colours, in such a way that
no two regions sharing a boundary have the same colour. You are
provided with some regions already coloured, sufficient to make the
remainder of the solution unique.

Only regions which share a length of border are required to be
different colours. Two regions which meet at only one \e{point}
(i.e. are diagonally separated) may be the same colour.

I believe this puzzle is original; I've never seen an implementation
of it anywhere else. The concept of a \i{four-colouring} puzzle was
suggested by Owen Dunn; credit must also go to Nikoli and to Verity
Allan for inspiring the train of thought that led to me realising
Owen's suggestion was a viable puzzle. Thanks also to Gareth Taylor
for many detailed suggestions.

\H{map-controls} \i{Map controls}

\IM{Map controls} controls, for Map

To colour a region, click the left mouse button on an existing
region of the desired colour and drag that colour into the new
region.

(The program will always ensure the starting puzzle has at least one
region of each colour, so that this is always possible!)

If you need to clear a region, you can drag from an empty region, or
from the puzzle boundary if there are no empty regions left.

Dragging a colour using the \e{right} mouse button will stipple the
region in that colour, which you can use as a note to yourself that
you think the region \e{might} be that colour. A region can contain
stipples in multiple colours at once. (This is often useful at the
harder difficulty levels.)

If you press L during play, the game will toggle display of a number
in each region of the map. This is useful if you want to discuss a
particular puzzle instance with a friend \dash having an unambiguous
name for each region is much easier than trying to refer to them all
by names such as \q{the one down and right of the brown one on the
top border}.

(All the actions described in \k{common-actions} are also available.)

\H{map-parameters} \I{parameters, for Map}Map parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{Regions}

\dd Number of regions in the generated map.

\dt \e{Difficulty}

\dd In \q{Easy} mode, there should always be at least one region
whose colour can be determined trivially. In \q{Normal} and \q{Hard}
modes, you will have to use increasingly complex logic to deduce the
colour of some regions. However, it will always be possible without
having to guess or backtrack.

\lcont{

In \q{Unreasonable} mode, the program will feel free to generate
puzzles which are as hard as it can possibly make them: the only
constraint is that they should still have a unique solution. Solving
Unreasonable puzzles may require guessing and backtracking.

}


\C{loopy} \i{Loopy}

\cfg{winhelp-topic}{games.loopy}

You are given a grid of dots. Your aim is to draw a single unbroken
loop from dot to dot within the grid.

Some of the square spaces between the dots contain numbers. These
numbers indicate how many of the four edges of that square are part
of the loop. The loop you draw must correctly satisfy all of these
clues to be considered a correct solution.

Credit for this puzzle goes to \i{Nikoli} \k{nikoli-loopy}.

Loopy was contributed to this collection by Mike Pinna.

\B{nikoli-loopy}
\W{http://www.nikoli.co.jp/puzzles/3/index-e.htm}\cw{http://www.nikoli.co.jp/puzzles/3/index-e.htm}
(beware of Flash)

\H{loopy-controls} \i{Loopy controls}

\IM{Loopy controls} controls, for Loopy

Click the left mouse button between two dots to add a line segment
connecting them. Click again to remove that line segment.

If you are sure that a particular line segment is \e{not} part of
the loop, you can click the right mouse button to add a small cross
indicating this. Click again to remove the cross.

(All the actions described in \k{common-actions} are also available.)

\H{loopy-parameters} \I{parameters, for Loopy}Loopy parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{Difficulty}

\dd Controls the difficulty of the generated puzzle.
\#{FIXME: what distinguishes Easy, Medium, and Hard? In particular,
when are backtracking/guesswork required, if ever?}


\C{inertia} \i{Inertia}

\cfg{winhelp-topic}{games.inertia}

You are a small green ball sitting in a grid full of obstacles. Your
aim is to collect all the gems without running into any mines.

You can move the ball in any orthogonal \e{or diagonal} direction.
Once the ball starts moving, it will continue until something stops
it. A wall directly in its path will stop it (but if it is moving
diagonally, it will move through a diagonal gap between two other
walls without stopping). Also, some of the squares are \q{stops};
when the ball moves on to a stop, it will stop moving no matter what
direction it was going in. Gems do \e{not} stop the ball; it picks
them up and keeps on going.

Running into a mine is fatal. Even if you picked up the last gem in
the same move which then hit a mine, the game will count you as dead
rather than victorious.

This game was originally implemented for Windows by Ben Olmstead
\k{bem}, who was kind enough to release his source code on request
so that it could be re-implemented for this collection.

\B{bem} \W{http://xn13.com/}\cw{http://xn13.com/}

\H{inertia-controls} \i{Inertia controls}

\IM{Inertia controls} controls, for Inertia
\IM{Inertia controls} keys, for Inertia
\IM{Inertia controls} shortcuts (keyboard), for Inertia

You can move the ball in any of the eight directions using the
numeric keypad. Alternatively, if you click the left mouse button on
the grid, the ball will begin a move in the general direction of
where you clicked.

If you use the \q{Solve} function on this game, the program will
compute a path through the grid which collects all the remaining
gems and returns to the current position. A hint arrow will appear
on the ball indicating the direction in which you should move to
begin on this path. If you then move in that direction, the arrow
will update to indicate the next direction on the path. You can also
press Space to automatically move in the direction of the hint
arrow. If you move in a different direction from the one shown by
the arrow, the hint arrows will stop appearing because you have
strayed from the provided path; you can then use \q{Solve} again to
generate a new path if you want to.

All the actions described in \k{common-actions} are also available.
In particular, if you do run into a mine and die, you can use the
Undo function and resume playing from before the fatal move. The
game will keep track of the number of times you have done this.

\H{inertia-parameters} \I{parameters, for Inertia}Inertia parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.


\C{tents} \i{Tents}

\cfg{winhelp-topic}{games.tents}

You have a grid of squares, some of which contain trees. Your aim is
to place tents in some of the remaining squares, in such a way that
the following conditions are met:

\b There are exactly as many tents as trees.

\b The tents and trees can be matched up in such a way that each
tent is directly adjacent (horizontally or vertically, but not
diagonally) to its own tree. However, a tent may be adjacent to
other trees as well as its own.

\b No two tents are adjacent horizontally, vertically \e{or
diagonally}.

\b The number of tents in each row, and in each column, matches the
numbers given round the sides of the grid.

This puzzle can be found in several places on the Internet, and was
brought to my attention by e-mail. I don't know who I should credit
for inventing it.

\H{tents-controls} \i{Tents controls}

\IM{Tents controls} controls, for Tents

Left-clicking in a blank square will place a tent in it.
Right-clicking in a blank square will colour it green, indicating
that you are sure it \e{isn't} a tent. Clicking either button in an
occupied square will clear it.

If you \e{drag} with the right button along a row or column, every
blank square in the region you cover will be turned green, and no
other squares will be affected. (This is useful for clearing the
remainder of a row once you have placed all its tents.)

(All the actions described in \k{common-actions} are also available.)

\H{tents-parameters} \I{parameters, for Tents}Tents parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{Difficulty}

\dd Controls the difficulty of the generated puzzle. More difficult
puzzles require more complex deductions, but at present none of the
available difficulty levels requires guesswork or backtracking.


\C{bridges} \i{Bridges}

\cfg{winhelp-topic}{games.bridges}

You have a set of islands distributed across the playing area. Each
island contains a number. Your aim is to connect the islands
together with bridges, in such a way that:

\b Bridges run horizontally or vertically.

\b The number of bridges terminating at any island is equal to the
number written in that island.

\b Two bridges may run in parallel between the same two islands, but
no more than two may do so.

\b No bridge crosses another bridge.

\b All the islands are connected together.

There are some configurable alternative modes, which involve
changing the parallel-bridge limit to something other than 2, and
introducing the additional constraint that no sequence of bridges
may form a loop from one island back to the same island. The rules
stated above are the default ones.

Credit for this puzzle goes to \i{Nikoli} \k{nikoli-bridges}.

Bridges was contributed to this collection by James Harvey.

\B{nikoli-bridges}
\W{http://www.nikoli.co.jp/puzzles/14/index-e.htm}\cw{http://www.nikoli.co.jp/puzzles/14/index-e.htm}

\H{bridges-controls} \i{Bridges controls}

\IM{Bridges controls} controls, for Bridges

To place a bridge between two islands, click the mouse down on one
island and drag it towards the other. You do not need to drag all
the way to the other island; you only need to move the mouse far
enough for the intended bridge direction to be unambiguous. (So you
can keep the mouse near the starting island and conveniently throw
bridges out from it in many directions.)

Doing this again when a bridge is already present will add another
parallel bridge. If there are already as many bridges between the
two islands as permitted by the current game rules (i.e. two by
default), the same dragging action will remove all of them.

If you want to remind yourself that two islands definitely \e{do
not} have a bridge between them, you can right-drag between them in
the same way to draw a \q{non-bridge} marker.

If you think you have finished with an island (i.e. you have placed
all its bridges and are confident that they are in the right
places), you can mark the island as finished by left-clicking on it.
This will highlight it and all the bridges connected to it, and you
will be prevented from accidentally modifying any of those bridges
in future. Left-clicking again on a highlighted island will unmark
it and restore your ability to modify it.

Violations of the puzzle rules will be marked in red:

\b An island with too many bridges will be highlighted in red.

\b An island with too few bridges will be highlighted in red if it
is definitely an error (as opposed to merely not being finished
yet): if adding enough bridges would involve having to cross another
bridge or remove a non-bridge marker, or if the island has been
highlighted as complete.

\b A group of islands and bridges may be highlighted in red if it is
a closed subset of the puzzle with no way to connect it to the rest
of the islands. For example, if you directly connect two 1s together
with a bridge and they are not the only two islands on the grid,
they will light up red to indicate that such a group cannot be
contained in any valid solution.

\b If you have selected the (non-default) option to disallow loops
in the solution, a group of bridges which forms a loop will be
highlighted.

(All the actions described in \k{common-actions} are also available.)

\H{bridges-parameters} \I{parameters, for Bridges}Bridges parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{Difficulty}

\dd Difficulty level of puzzle.

\dt \e{Allow loops}

\dd This is set by default. If cleared, puzzles will be generated in
such a way that they are always soluble without creating a loop, and
solutions which do involve a loop will be disallowed.

\dt \e{Max. bridges per direction}

\dd Maximum number of bridges in any particular direction. The
default is 2, but you can change it to 1, 3 or 4. In general, fewer
is easier.

\dt \e{%age of island squares}

\dd Gives a rough percentage of islands the generator will try and
lay before finishing the puzzle. Certain layouts will not manage to
lay enough islands; this is an upper bound.

\dt \e{Expansion factor (%age)}

\dd The grid generator works by picking an existing island at random
(after first creating an initial island somewhere). It then decides
on a direction (at random), and then works out how far it could
extend before creating another island. This parameter determines how
likely it is to extend as far as it can, rather than choosing
somewhere closer.

High expansion factors usually mean easier puzzles with fewer
possible islands; low expansion factors can create lots of
tightly-packed islands.


\C{unequal} \i{Unequal}

\cfg{winhelp-topic}{games.unequal}

You have a square grid; each square may contain a digit from 1 to
the size of the grid, and some squares have greater-than signs between
them. Your aim is to fully populate the grid with numbers such that:

\b Each row contains only one occurrence of each digit

\b Each column contains only one occurrence of each digit

\b All the greater-than signs are satisfied. 

In \q{Trivial} mode (available via the \q{Custom} game type
selector), there are no greater-than signs; the puzzle is to solve
the \i{Latin square} only.

At the time of writing, this puzzle is appearing in the Guardian
weekly under the name \q{\i{Futoshiki}}.

Unequal was contributed to this collection by James Harvey.

\H{unequal-controls} \i{Unequal controls}

\IM{Unequal controls} controls, for Unequal

Unequal shares much of its control system with Solo.

To play Unequal, simply click the mouse in any empty square and then
type a digit or letter on the keyboard to fill that square. If you
make a mistake, click the mouse in the incorrect square and press
Space to clear it again (or use the Undo feature).

If you \e{right}-click in a square and then type a number, that
number will be entered in the square as a \q{pencil mark}. You can
have pencil marks for multiple numbers in the same square.

The game pays no attention to pencil marks, so exactly what you use
them for is up to you: you can use them as reminders that a
particular square needs to be re-examined once you know more about a
particular number, or you can use them as lists of the possible
numbers in a given square, or anything else you feel like.

To erase a single pencil mark, right-click in the square and type
the same number again.

All pencil marks in a square are erased when you left-click and type
a number, or when you left-click and press space. Right-clicking and
pressing space will also erase pencil marks.

(All the actions described in \k{common-actions} are also available.)

\H{unequal-parameters} \I{parameters, for Unequal}Unequal parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Size (s*s)}

\dd Size of grid.

\dt \e{Difficulty}

\dd Controls the difficulty of the generated puzzle. At Trivial
level, there are no greater-than signs; the puzzle is to solve the
Latin square only. At Recursive level (only available via the
\q{Custom} game type selector) backtracking will be required, but
the solution should still be unique. The levels in between require
increasingly complex reasoning to avoid having to backtrack.



\C{galaxies} \i{Galaxies}

\cfg{winhelp-topic}{games.galaxies}

You have a rectangular grid containing a number of dots. Your aim is
to draw edges along the grid lines which divide the rectangle into
regions in such a way that every region is 180\u00b0{-degree}
rotationally symmetric, and contains exactly one dot which is
located at its centre of symmetry.

This puzzle was invented by \i{Nikoli} \k{nikoli-galaxies}, under
the name \q{Tentai Show}; its name is commonly translated into
English as \q{Spiral Galaxies}.

Galaxies was contributed to this collection by James Harvey.

\B{nikoli-galaxies} \W{http://www.nikoli.co.jp/en/puzzles/astronomical_show/}\cw{http://www.nikoli.co.jp/en/puzzles/astronomical_show/}

\H{galaxies-controls} \i{Galaxies controls}

\IM{Galaxies controls} controls, for Galaxies

Left-click on any grid line to draw an edge if there isn't one
already, or to remove one if there is. When you create a valid
region (one which is closed, contains exactly one dot, is
180\u00b0{-degree} symmetric about that dot, and contains no
extraneous edges inside it) it will be highlighted automatically; so
your aim is to have the whole grid highlighted in that way.

During solving, you might know that a particular grid square belongs
to a specific dot, but not be sure of where the edges go and which
other squares are connected to the dot. In order to mark this so you
don't forget, you can right-click on the dot and drag, which will
create an arrow marker pointing at the dot. Drop that in a square of
your choice and it will remind you which dot it's associated with.
You can also right-click on existing arrows to pick them up and move
them, or destroy them by dropping them off the edge of the grid.
(Also, if you're not sure which dot an arrow is pointing at, you can
pick it up and move it around to make it clearer. It will swivel
constantly as you drag it, to stay pointed at its parent dot.)

(All the actions described in \k{common-actions} are also available.)

\H{galaxies-parameters} \I{parameters, for Galaxies}Galaxies parameters

These parameters are available from the \q{Custom...} option on the
\q{Type} menu.

\dt \e{Width}, \e{Height}

\dd Size of grid in squares.

\dt \e{Difficulty}

\dd Controls the difficulty of the generated puzzle. More difficult
puzzles require more complex deductions, and the \q{Unreasonable}
difficulty level may require backtracking.



\C{filling} \i{Filling}

\cfg{winhelp-topic}{games.filling}

You have a grid of squares, some of which contain digits, and the
rest of which are empty. Your job is to fill in digits in the empty
squares, in such a way that each connected region of squares all
containing the same digit has an area equal to that digit.

(\q{Connected region}, for the purposes of this game, does not count
diagonally separated squares as adjacent.)

For example, it follows that no square can contain a zero, and that
two adjacent squares can not both contain a one.  No region has an
area greater than 9 (because then its area would not be a single
digit).

Credit for this puzzle goes to \i{Nikoli} \k{nikoli-fillomino}.

Filling was contributed to this collection by Jonas K\u00F6{oe}lker.

\B{nikoli-fillomino}
\W{http://www.nikoli.co.jp/en/puzzles/fillomino/}\cw{http://www.nikoli.co.jp/en/puzzles/fillomino/}

\H{filling-controls} \I{controls, for Filling}Filling controls

To play Filling, simply click the mouse in any empty square and then
type a digit on the keyboard to fill that square. By dragging the
mouse, you can select multiple squares to fill with a single keypress.
If you make a mistake, click the mouse in the incorrect square and
press 0, Space, Backspace or Enter to clear it again (or use the Undo
feature).

(All the actions described in \k{common-actions} are also available.)

\H{filling-parameters} \I{parameters, for Filling}Filling parameters

Filling allows you to configure the number of rows and columns of the
grid, through the \q{Type} menu.



\A{licence} \I{MIT licence}\ii{Licence}

This software is \i{copyright} 2004-2008 Simon Tatham.

Portions copyright Richard Boulton, James Harvey, Mike Pinna and
Jonas K\u00F6{oe}lker.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the \q{Software}), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software,
and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED \q{AS IS}, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

\IM{command-line}{command line} command line

\IM{default parameters, specifying} default parameters, specifying
\IM{default parameters, specifying} preferences, specifying default

\IM{Unix} Unix
\IM{Unix} Linux

\IM{generating game IDs} generating game IDs
\IM{generating game IDs} game ID, generating

\IM{specific} \q{Specific}, menu option
\IM{custom} \q{Custom}, menu option

\IM{game ID} game ID
\IM{game ID} ID, game
\IM{ID format} ID format
\IM{ID format} format, ID
\IM{ID format} game ID, format

\IM{keys} keys
\IM{keys} shortcuts (keyboard)

\IM{initial state} initial state
\IM{initial state} state, initial

\IM{MIT licence} MIT licence
\IM{MIT licence} licence, MIT
